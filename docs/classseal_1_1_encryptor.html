<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEAL: seal::Encryptor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SEAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>seal</b></li><li class="navelem"><a class="el" href="classseal_1_1_encryptor.html">Encryptor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseal_1_1_encryptor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">seal::Encryptor Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="encryptor_8h_source.html">encryptor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2e2ad859897b919711c2cb7e5179bca9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#a2e2ad859897b919711c2cb7e5179bca9">Encryptor</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, const <a class="el" href="classseal_1_1_public_key.html">PublicKey</a> &amp;public_key)</td></tr>
<tr class="separator:a2e2ad859897b919711c2cb7e5179bca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fea8a29d0e292a1192633a2c9f39cd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#a6fea8a29d0e292a1192633a2c9f39cd3">Encryptor</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, const <a class="el" href="classseal_1_1_secret_key.html">SecretKey</a> &amp;secret_key)</td></tr>
<tr class="separator:a6fea8a29d0e292a1192633a2c9f39cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822d23ec26a69f2c8d1cb884e1495693"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#a822d23ec26a69f2c8d1cb884e1495693">Encryptor</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, const <a class="el" href="classseal_1_1_public_key.html">PublicKey</a> &amp;public_key, const <a class="el" href="classseal_1_1_secret_key.html">SecretKey</a> &amp;secret_key)</td></tr>
<tr class="separator:a822d23ec26a69f2c8d1cb884e1495693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a321529b5a0e99445c45602e7172c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#ac1a321529b5a0e99445c45602e7172c9">set_public_key</a> (const <a class="el" href="classseal_1_1_public_key.html">PublicKey</a> &amp;public_key)</td></tr>
<tr class="separator:ac1a321529b5a0e99445c45602e7172c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae564f5ae2d9f7e794c8b0ca16d6821fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#ae564f5ae2d9f7e794c8b0ca16d6821fe">set_secret_key</a> (const <a class="el" href="classseal_1_1_secret_key.html">SecretKey</a> &amp;secret_key)</td></tr>
<tr class="separator:ae564f5ae2d9f7e794c8b0ca16d6821fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0ea5df717474085feabb3a03f6b896"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#afc0ea5df717474085feabb3a03f6b896">encrypt</a> (const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;plain, <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:afc0ea5df717474085feabb3a03f6b896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c3dd69276e89ea39c4349218a5600d"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#ae5c3dd69276e89ea39c4349218a5600d">encrypt</a> (const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;plain, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:ae5c3dd69276e89ea39c4349218a5600d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8ae994ef38ee0c469f29f8c297d866"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#afd8ae994ef38ee0c469f29f8c297d866">encrypt_zero</a> (<a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:afd8ae994ef38ee0c469f29f8c297d866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ba7f3da998a88df9822b1b63c8b700"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#a32ba7f3da998a88df9822b1b63c8b700">encrypt_zero</a> (parms_id_type parms_id, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:a32ba7f3da998a88df9822b1b63c8b700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea22b3c8c0d4ab0df87dec9d5db205a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#a3ea22b3c8c0d4ab0df87dec9d5db205a">encrypt_zero</a> (parms_id_type parms_id, <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:a3ea22b3c8c0d4ab0df87dec9d5db205a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f32e3746d1ddb1b273f93a4e42dd05"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#a25f32e3746d1ddb1b273f93a4e42dd05">encrypt_zero</a> (<a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:a25f32e3746d1ddb1b273f93a4e42dd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7993a1a752278f438b9a21dbb75d158"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#aa7993a1a752278f438b9a21dbb75d158">encrypt_symmetric</a> (const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;plain, <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:aa7993a1a752278f438b9a21dbb75d158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f45547223346e3d3149f37d5f7e36a2"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#a1f45547223346e3d3149f37d5f7e36a2">encrypt_symmetric</a> (const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;plain, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:a1f45547223346e3d3149f37d5f7e36a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd77f4149f9b64cbc8d62b765a00fcac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#afd77f4149f9b64cbc8d62b765a00fcac">encrypt_zero_symmetric</a> (parms_id_type parms_id, <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:afd77f4149f9b64cbc8d62b765a00fcac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cd7149857b9ba1f731ef15b16c5f0a"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#a62cd7149857b9ba1f731ef15b16c5f0a">encrypt_zero_symmetric</a> (parms_id_type parms_id, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:a62cd7149857b9ba1f731ef15b16c5f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1311f08d3552dbbb1cc5346e214ca89c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#a1311f08d3552dbbb1cc5346e214ca89c">encrypt_zero_symmetric</a> (<a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;destination, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:a1311f08d3552dbbb1cc5346e214ca89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc0b4f7d000a30247f8bff56235d6ed"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_encryptor.html#aabc0b4f7d000a30247f8bff56235d6ed">encrypt_zero_symmetric</a> (<a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:aabc0b4f7d000a30247f8bff56235d6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encrypts <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> objects into <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> objects. Constructing an <a class="el" href="classseal_1_1_encryptor.html">Encryptor</a> requires a <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> with valid encryption parameters, the public key and/or the secret key. If an Encrytor is given a secret key, it supports symmetric-key encryption. If an <a class="el" href="classseal_1_1_encryptor.html">Encryptor</a> is given a public key, it supports asymmetric-key encryption.</p>
<dl class="section user"><dt>Overloads</dt><dd>For the encrypt function we provide two overloads concerning the memory pool used in allocations needed during the operation. In one overload the global memory pool is used for this purpose, and in another overload the user can supply a <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> to to be used instead. This is to allow one single <a class="el" href="classseal_1_1_encryptor.html">Encryptor</a> to be used concurrently by several threads without running into thread contention in allocations taking place during operations. For example, one can share one single <a class="el" href="classseal_1_1_encryptor.html">Encryptor</a> across any number of threads, but in each thread call the encrypt function by giving it a thread-local <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> to use. It is important for a developer to understand how this works to avoid unnecessary performance bottlenecks.</dd></dl>
<dl class="section user"><dt>NTT form</dt><dd>When using the BFV/BGV scheme (scheme_type::bfv/bgv), all plaintext and ciphertexts should remain by default in the usual coefficient representation, i.e. not in NTT form. When using the CKKS scheme (scheme_type::ckks), all plaintexts and ciphertexts should remain by default in NTT form. We call these scheme-specific NTT states the "default NTT form". Decryption requires the input ciphertexts to be in the default NTT form, and will throw an exception if this is not the case. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2e2ad859897b919711c2cb7e5179bca9" name="a2e2ad859897b919711c2cb7e5179bca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2ad859897b919711c2cb7e5179bca9">&#9670;&#160;</a></span>Encryptor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">seal::Encryptor::Encryptor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_public_key.html">PublicKey</a> &amp;&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an <a class="el" href="classseal_1_1_encryptor.html">Encryptor</a> instance initialized with the specified <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> and public key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>The public key </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if public_key is not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fea8a29d0e292a1192633a2c9f39cd3" name="a6fea8a29d0e292a1192633a2c9f39cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fea8a29d0e292a1192633a2c9f39cd3">&#9670;&#160;</a></span>Encryptor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">seal::Encryptor::Encryptor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_secret_key.html">SecretKey</a> &amp;&#160;</td>
          <td class="paramname"><em>secret_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an <a class="el" href="classseal_1_1_encryptor.html">Encryptor</a> instance initialized with the specified <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> and secret key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secret_key</td><td>The secret key </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if secret_key is not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a822d23ec26a69f2c8d1cb884e1495693" name="a822d23ec26a69f2c8d1cb884e1495693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822d23ec26a69f2c8d1cb884e1495693">&#9670;&#160;</a></span>Encryptor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">seal::Encryptor::Encryptor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_public_key.html">PublicKey</a> &amp;&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_secret_key.html">SecretKey</a> &amp;&#160;</td>
          <td class="paramname"><em>secret_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an <a class="el" href="classseal_1_1_encryptor.html">Encryptor</a> instance initialized with the specified <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a>, secret key, and public key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>The public key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secret_key</td><td>The secret key </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if public_key or secret_key is not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afc0ea5df717474085feabb3a03f6b896" name="afc0ea5df717474085feabb3a03f6b896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0ea5df717474085feabb3a03f6b896">&#9670;&#160;</a></span>encrypt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Encryptor::encrypt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encrypts a plaintext with the public key and stores the result in destination.</p>
<p>The encryption parameters for the resulting ciphertext correspond to: 1) in BFV/BGV, the highest (data) level in the modulus switching chain, 2) in CKKS, the encryption parameters of the plaintext. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to encrypt </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the encrypted plaintext </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a public key is not set </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not in default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5c3dd69276e89ea39c4349218a5600d" name="ae5c3dd69276e89ea39c4349218a5600d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c3dd69276e89ea39c4349218a5600d">&#9670;&#160;</a></span>encrypt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &gt; seal::Encryptor::encrypt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encrypts a plaintext with the public key and returns the ciphertext as a serializable object.</p>
<p>The encryption parameters for the resulting ciphertext correspond to: 1) in BFV/BGV, the highest (data) level in the modulus switching chain, 2) in CKKS, the encryption parameters of the plaintext. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to encrypt </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a public key is not set </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not in default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7993a1a752278f438b9a21dbb75d158" name="aa7993a1a752278f438b9a21dbb75d158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7993a1a752278f438b9a21dbb75d158">&#9670;&#160;</a></span>encrypt_symmetric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Encryptor::encrypt_symmetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encrypts a plaintext with the secret key and stores the result in destination.</p>
<p>The encryption parameters for the resulting ciphertext correspond to: 1) in BFV/BGV, the highest (data) level in the modulus switching chain, 2) in CKKS, the encryption parameters of the plaintext. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to encrypt </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the encrypted plaintext </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a secret key is not set </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not in default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f45547223346e3d3149f37d5f7e36a2" name="a1f45547223346e3d3149f37d5f7e36a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f45547223346e3d3149f37d5f7e36a2">&#9670;&#160;</a></span>encrypt_symmetric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &gt; seal::Encryptor::encrypt_symmetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encrypts a plaintext with the secret key and returns the ciphertext as a serializable object.</p>
<p>Half of the ciphertext data is pseudo-randomly generated from a seed to reduce the object size. The resulting serializable object cannot be used directly and is meant to be serialized for the size reduction to have an impact.</p>
<p>The encryption parameters for the resulting ciphertext correspond to: 1) in BFV/BGV, the highest (data) level in the modulus switching chain, 2) in CKKS, the encryption parameters of the plaintext. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to encrypt </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a secret key is not set </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not in default NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd8ae994ef38ee0c469f29f8c297d866" name="afd8ae994ef38ee0c469f29f8c297d866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8ae994ef38ee0c469f29f8c297d866">&#9670;&#160;</a></span>encrypt_zero() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Encryptor::encrypt_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encrypts a zero plaintext with the public key and stores the result in destination.</p>
<p>The encryption parameters for the resulting ciphertext correspond to the highest (data) level in the modulus switching chain. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the encrypted plaintext </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a public key is not set </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25f32e3746d1ddb1b273f93a4e42dd05" name="a25f32e3746d1ddb1b273f93a4e42dd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f32e3746d1ddb1b273f93a4e42dd05">&#9670;&#160;</a></span>encrypt_zero() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &gt; seal::Encryptor::encrypt_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encrypts a zero plaintext with the public key and returns the ciphertext as a serializable object.</p>
<p>The encryption parameters for the resulting ciphertext correspond to the highest (data) level in the modulus switching chain. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a public key is not set </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ea22b3c8c0d4ab0df87dec9d5db205a" name="a3ea22b3c8c0d4ab0df87dec9d5db205a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea22b3c8c0d4ab0df87dec9d5db205a">&#9670;&#160;</a></span>encrypt_zero() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Encryptor::encrypt_zero </td>
          <td>(</td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encrypts a zero plaintext with the public key and stores the result in destination.</p>
<p>The encryption parameters for the resulting ciphertext correspond to the given parms_id. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>The parms_id for the resulting ciphertext </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the encrypted plaintext </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a public key is not set </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32ba7f3da998a88df9822b1b63c8b700" name="a32ba7f3da998a88df9822b1b63c8b700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ba7f3da998a88df9822b1b63c8b700">&#9670;&#160;</a></span>encrypt_zero() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &gt; seal::Encryptor::encrypt_zero </td>
          <td>(</td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encrypts a zero plaintext with the public key and returns the ciphertext as a serializable object.</p>
<p>The encryption parameters for the resulting ciphertext correspond to the given parms_id. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>The parms_id for the resulting ciphertext </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a public key is not set </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1311f08d3552dbbb1cc5346e214ca89c" name="a1311f08d3552dbbb1cc5346e214ca89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1311f08d3552dbbb1cc5346e214ca89c">&#9670;&#160;</a></span>encrypt_zero_symmetric() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Encryptor::encrypt_zero_symmetric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encrypts a zero plaintext with the secret key and stores the result in destination.</p>
<p>The encryption parameters for the resulting ciphertext correspond to the highest (data) level in the modulus switching chain. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the encrypted plaintext </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a secret key is not set </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabc0b4f7d000a30247f8bff56235d6ed" name="aabc0b4f7d000a30247f8bff56235d6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc0b4f7d000a30247f8bff56235d6ed">&#9670;&#160;</a></span>encrypt_zero_symmetric() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &gt; seal::Encryptor::encrypt_zero_symmetric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encrypts a zero plaintext with the secret key and returns the ciphertext as a serializable object.</p>
<p>Half of the ciphertext data is pseudo-randomly generated from a seed to reduce the object size. The resulting serializable object cannot be used directly and is meant to be serialized for the size reduction to have an impact.</p>
<p>The encryption parameters for the resulting ciphertext correspond to the highest (data) level in the modulus switching chain. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a secret key is not set </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd77f4149f9b64cbc8d62b765a00fcac" name="afd77f4149f9b64cbc8d62b765a00fcac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd77f4149f9b64cbc8d62b765a00fcac">&#9670;&#160;</a></span>encrypt_zero_symmetric() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Encryptor::encrypt_zero_symmetric </td>
          <td>(</td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encrypts a zero plaintext with the secret key and stores the result in destination.</p>
<p>The encryption parameters for the resulting ciphertext correspond to the given parms_id. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>The parms_id for the resulting ciphertext </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The ciphertext to overwrite with the encrypted plaintext </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a secret key is not set </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62cd7149857b9ba1f731ef15b16c5f0a" name="a62cd7149857b9ba1f731ef15b16c5f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62cd7149857b9ba1f731ef15b16c5f0a">&#9670;&#160;</a></span>encrypt_zero_symmetric() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &gt; seal::Encryptor::encrypt_zero_symmetric </td>
          <td>(</td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encrypts a zero plaintext with the secret key and returns the ciphertext as a serializable object.</p>
<p>Half of the ciphertext data is pseudo-randomly generated from a seed to reduce the object size. The resulting serializable object cannot be used directly and is meant to be serialized for the size reduction to have an impact.</p>
<p>The encryption parameters for the resulting ciphertext correspond to the given parms_id. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>The parms_id for the resulting ciphertext </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a secret key is not set </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1a321529b5a0e99445c45602e7172c9" name="ac1a321529b5a0e99445c45602e7172c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a321529b5a0e99445c45602e7172c9">&#9670;&#160;</a></span>set_public_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Encryptor::set_public_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_public_key.html">PublicKey</a> &amp;&#160;</td>
          <td class="paramname"><em>public_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Give a new instance of public key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>The public key </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if public_key is not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae564f5ae2d9f7e794c8b0ca16d6821fe" name="ae564f5ae2d9f7e794c8b0ca16d6821fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae564f5ae2d9f7e794c8b0ca16d6821fe">&#9670;&#160;</a></span>set_secret_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Encryptor::set_secret_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_secret_key.html">SecretKey</a> &amp;&#160;</td>
          <td class="paramname"><em>secret_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Give a new instance of secret key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">secret_key</td><td>The secret key </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if secret_key is not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>seal/<a class="el" href="encryptor_8h_source.html">encryptor.h</a></li>
<li>seal/encryptor.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
