<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEAL: seal::Plaintext Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SEAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>seal</b></li><li class="navelem"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classseal_1_1_plaintext-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">seal::Plaintext Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="plaintext_8h_source.html">plaintext.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a14d0072bb54ed8c9d5e8b6f1e34c7c2c"><td class="memItemLeft" align="right" valign="top"><a id="a14d0072bb54ed8c9d5e8b6f1e34c7c2c" name="a14d0072bb54ed8c9d5e8b6f1e34c7c2c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pt_coeff_type</b> = std::uint64_t</td></tr>
<tr class="separator:a14d0072bb54ed8c9d5e8b6f1e34c7c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac720e0a1a370ff93b623be748b166956"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#ac720e0a1a370ff93b623be748b166956">Plaintext</a> (<a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1_plaintext.html#a00ebd136a670476537c5941e99a80e33">pool</a>=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:ac720e0a1a370ff93b623be748b166956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf15f02984276a0cd18ff823931f3f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#afaf15f02984276a0cd18ff823931f3f8">Plaintext</a> (std::size_t <a class="el" href="classseal_1_1_plaintext.html#aef4d6b331be5b87ffbaae9326fe2db53">coeff_count</a>, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1_plaintext.html#a00ebd136a670476537c5941e99a80e33">pool</a>=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:afaf15f02984276a0cd18ff823931f3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82e65730322ba4de3906940223cc59b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#ab82e65730322ba4de3906940223cc59b">Plaintext</a> (std::size_t <a class="el" href="classseal_1_1_plaintext.html#ad07f5bf2f7590622a033244ab67161b7">capacity</a>, std::size_t <a class="el" href="classseal_1_1_plaintext.html#aef4d6b331be5b87ffbaae9326fe2db53">coeff_count</a>, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1_plaintext.html#a00ebd136a670476537c5941e99a80e33">pool</a>=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:ab82e65730322ba4de3906940223cc59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a6815db36aff2d7366d089cf4b0e2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a01a6815db36aff2d7366d089cf4b0e2b">Plaintext</a> (const std::string &amp;hex_poly, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1_plaintext.html#a00ebd136a670476537c5941e99a80e33">pool</a>=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a01a6815db36aff2d7366d089cf4b0e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d5a33b5f483f7036e77bdb5ecc3a0e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a73d5a33b5f483f7036e77bdb5ecc3a0e">Plaintext</a> (const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;copy)=default</td></tr>
<tr class="separator:a73d5a33b5f483f7036e77bdb5ecc3a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b8a8a17ceb6f40c0f3af31d312652e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a44b8a8a17ceb6f40c0f3af31d312652e">Plaintext</a> (<a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&amp;source)=default</td></tr>
<tr class="separator:a44b8a8a17ceb6f40c0f3af31d312652e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73f65284edf13cea0d1999f1ca535c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#aa73f65284edf13cea0d1999f1ca535c1">Plaintext</a> (const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;copy, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1_plaintext.html#a00ebd136a670476537c5941e99a80e33">pool</a>)</td></tr>
<tr class="separator:aa73f65284edf13cea0d1999f1ca535c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb33767af974ef6d9996956ccf76b977"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#acb33767af974ef6d9996956ccf76b977">reserve</a> (std::size_t <a class="el" href="classseal_1_1_plaintext.html#ad07f5bf2f7590622a033244ab67161b7">capacity</a>)</td></tr>
<tr class="separator:acb33767af974ef6d9996956ccf76b977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9da5b93c14bbf3be8eef7276e8852f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#af9da5b93c14bbf3be8eef7276e8852f7">shrink_to_fit</a> ()</td></tr>
<tr class="separator:af9da5b93c14bbf3be8eef7276e8852f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c2b6a99a59b09c21c77eee8075d3f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a29c2b6a99a59b09c21c77eee8075d3f8">release</a> () noexcept</td></tr>
<tr class="separator:a29c2b6a99a59b09c21c77eee8075d3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10c6e3e01730199d2cddfdca480e039"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#af10c6e3e01730199d2cddfdca480e039">resize</a> (std::size_t <a class="el" href="classseal_1_1_plaintext.html#aef4d6b331be5b87ffbaae9326fe2db53">coeff_count</a>)</td></tr>
<tr class="separator:af10c6e3e01730199d2cddfdca480e039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b8be6d4882f1d0933aecb7362f4828"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a32b8be6d4882f1d0933aecb7362f4828">operator=</a> (const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;assign)=default</td></tr>
<tr class="separator:a32b8be6d4882f1d0933aecb7362f4828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ce7cc2bee62b8525f1d063e1605507"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a13ce7cc2bee62b8525f1d063e1605507">operator=</a> (<a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&amp;assign)=default</td></tr>
<tr class="separator:a13ce7cc2bee62b8525f1d063e1605507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2830894c1f852b0955a7c637299aea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a3f2830894c1f852b0955a7c637299aea">operator=</a> (const std::string &amp;hex_poly)</td></tr>
<tr class="separator:a3f2830894c1f852b0955a7c637299aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa58981ed6d6128f30e751c836cd779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#affa58981ed6d6128f30e751c836cd779">operator=</a> (pt_coeff_type const_coeff)</td></tr>
<tr class="separator:affa58981ed6d6128f30e751c836cd779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2539b60c9a71d6e32dce953b62ecd0d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a2539b60c9a71d6e32dce953b62ecd0d1">set_zero</a> (std::size_t start_coeff, std::size_t length)</td></tr>
<tr class="separator:a2539b60c9a71d6e32dce953b62ecd0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0b8c48042aa5b0a992f3008ea50d66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#adb0b8c48042aa5b0a992f3008ea50d66">set_zero</a> (std::size_t start_coeff)</td></tr>
<tr class="separator:adb0b8c48042aa5b0a992f3008ea50d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe996fc6fc8a5296a7b242d260f7003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#adbe996fc6fc8a5296a7b242d260f7003">set_zero</a> ()</td></tr>
<tr class="separator:adbe996fc6fc8a5296a7b242d260f7003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a83dbf94a51977c45412eb0cc760eb"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a87a83dbf94a51977c45412eb0cc760eb">dyn_array</a> () const noexcept</td></tr>
<tr class="separator:a87a83dbf94a51977c45412eb0cc760eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc008a7387da45f5035d12fbb67936c"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD pt_coeff_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a3cc008a7387da45f5035d12fbb67936c">data</a> ()</td></tr>
<tr class="separator:a3cc008a7387da45f5035d12fbb67936c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2717a53f84b96ddcfef454354ca8cd8a"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const pt_coeff_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a2717a53f84b96ddcfef454354ca8cd8a">data</a> () const</td></tr>
<tr class="separator:a2717a53f84b96ddcfef454354ca8cd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f89b3a748ad32983d8b3e41f97b4749"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD pt_coeff_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a8f89b3a748ad32983d8b3e41f97b4749">data</a> (std::size_t coeff_index)</td></tr>
<tr class="separator:a8f89b3a748ad32983d8b3e41f97b4749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccb98bb396ca910b144b340a966c52e"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const pt_coeff_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a6ccb98bb396ca910b144b340a966c52e">data</a> (std::size_t coeff_index) const</td></tr>
<tr class="separator:a6ccb98bb396ca910b144b340a966c52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fea06a4e0d493a6f9813007b5c74743"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const pt_coeff_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a6fea06a4e0d493a6f9813007b5c74743">operator[]</a> (std::size_t coeff_index) const</td></tr>
<tr class="separator:a6fea06a4e0d493a6f9813007b5c74743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49357382074eff559e0d43a48559f7d"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD pt_coeff_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#ac49357382074eff559e0d43a48559f7d">operator[]</a> (std::size_t coeff_index)</td></tr>
<tr class="separator:ac49357382074eff559e0d43a48559f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d192324435bc7e237756df3566fc1c3"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a1d192324435bc7e237756df3566fc1c3">operator==</a> (const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;compare) const</td></tr>
<tr class="separator:a1d192324435bc7e237756df3566fc1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77c067cd07a16c7e29b97fc6d886e97"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#ab77c067cd07a16c7e29b97fc6d886e97">operator!=</a> (const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;compare) const</td></tr>
<tr class="separator:ab77c067cd07a16c7e29b97fc6d886e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb309fcc897361c1371da08952b2867"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#aabb309fcc897361c1371da08952b2867">is_zero</a> () const</td></tr>
<tr class="separator:aabb309fcc897361c1371da08952b2867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07f5bf2f7590622a033244ab67161b7"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#ad07f5bf2f7590622a033244ab67161b7">capacity</a> () const noexcept</td></tr>
<tr class="separator:ad07f5bf2f7590622a033244ab67161b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4d6b331be5b87ffbaae9326fe2db53"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#aef4d6b331be5b87ffbaae9326fe2db53">coeff_count</a> () const noexcept</td></tr>
<tr class="separator:aef4d6b331be5b87ffbaae9326fe2db53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad488313cf7e15eb3be0327b3b896072"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#aad488313cf7e15eb3be0327b3b896072">significant_coeff_count</a> () const</td></tr>
<tr class="separator:aad488313cf7e15eb3be0327b3b896072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607f4416dd7c7acc58ccd277e9878376"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a607f4416dd7c7acc58ccd277e9878376">nonzero_coeff_count</a> () const</td></tr>
<tr class="separator:a607f4416dd7c7acc58ccd277e9878376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ea95954eca1900072165cf7328e651"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#ad6ea95954eca1900072165cf7328e651">to_string</a> () const</td></tr>
<tr class="separator:ad6ea95954eca1900072165cf7328e651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac601de584be9f7d4d96543fcb47868a6"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#ac601de584be9f7d4d96543fcb47868a6">save_size</a> (compr_mode_type compr_mode=<a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a>) const</td></tr>
<tr class="separator:ac601de584be9f7d4d96543fcb47868a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5136783dde07fde0b4c76acc01422e"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a4e5136783dde07fde0b4c76acc01422e">save</a> (std::ostream &amp;stream, compr_mode_type compr_mode=<a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a>) const</td></tr>
<tr class="separator:a4e5136783dde07fde0b4c76acc01422e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6ded783346dda1fed68ecbd575cb76"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a4c6ded783346dda1fed68ecbd575cb76">unsafe_load</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, std::istream &amp;stream)</td></tr>
<tr class="separator:a4c6ded783346dda1fed68ecbd575cb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26893c6ce73355e3d69a869b8e5455bc"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a26893c6ce73355e3d69a869b8e5455bc">load</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, std::istream &amp;stream)</td></tr>
<tr class="separator:a26893c6ce73355e3d69a869b8e5455bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb65a3de6a3d6d71e5c1c80919eea60f"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#abb65a3de6a3d6d71e5c1c80919eea60f">save</a> (seal_byte *out, std::size_t size, compr_mode_type compr_mode=<a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a>) const</td></tr>
<tr class="separator:abb65a3de6a3d6d71e5c1c80919eea60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c306c36d377d91359b4041402a9fbe"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#ab0c306c36d377d91359b4041402a9fbe">unsafe_load</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, const seal_byte *in, std::size_t size)</td></tr>
<tr class="separator:ab0c306c36d377d91359b4041402a9fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8c2c4a470fd028c9e78ccdd9942b98"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#acc8c2c4a470fd028c9e78ccdd9942b98">load</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, const seal_byte *in, std::size_t size)</td></tr>
<tr class="separator:acc8c2c4a470fd028c9e78ccdd9942b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf0a51529161f3fcd7cdcdd45d9171a"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a7cf0a51529161f3fcd7cdcdd45d9171a">is_ntt_form</a> () const noexcept</td></tr>
<tr class="separator:a7cf0a51529161f3fcd7cdcdd45d9171a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af643a3b656727d350ed3206ea65adf40"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD parms_id_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#af643a3b656727d350ed3206ea65adf40">parms_id</a> () noexcept</td></tr>
<tr class="separator:af643a3b656727d350ed3206ea65adf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c3e309fcfa4648a3df2539d69facd1"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const parms_id_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a02c3e309fcfa4648a3df2539d69facd1">parms_id</a> () const noexcept</td></tr>
<tr class="separator:a02c3e309fcfa4648a3df2539d69facd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958fcd7c2bb3b1efc8bc8ccb1c6dc575"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a958fcd7c2bb3b1efc8bc8ccb1c6dc575">scale</a> () noexcept</td></tr>
<tr class="separator:a958fcd7c2bb3b1efc8bc8ccb1c6dc575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a664bfea6515b3a3da420f431f451b6"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a1a664bfea6515b3a3da420f431f451b6">scale</a> () const noexcept</td></tr>
<tr class="separator:a1a664bfea6515b3a3da420f431f451b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ebd136a670476537c5941e99a80e33"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_plaintext.html#a00ebd136a670476537c5941e99a80e33">pool</a> () const noexcept</td></tr>
<tr class="separator:a00ebd136a670476537c5941e99a80e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9300c9d218be169fff5b7542e4b41ea0"><td class="memItemLeft" align="right" valign="top"><a id="a9300c9d218be169fff5b7542e4b41ea0" name="a9300c9d218be169fff5b7542e4b41ea0"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SecretKey</b></td></tr>
<tr class="separator:a9300c9d218be169fff5b7542e4b41ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to store a plaintext element. The data for the plaintext is a polynomial with coefficients modulo the plaintext modulus. The degree of the plaintext polynomial must be one less than the degree of the polynomial modulus. The backing array always allocates one 64-bit word per each coefficient of the polynomial.</p>
<dl class="section user"><dt>Memory Management</dt><dd>The coefficient count of a plaintext refers to the number of word-size coefficients in the plaintext, whereas its capacity refers to the number of word-size coefficients that fit in the current memory allocation. In high- performance applications unnecessary re-allocations should be avoided by reserving enough memory for the plaintext to begin with either by providing the desired capacity to the constructor as an extra argument, or by calling the reserve function at any time.</dd></dl>
<p>When the scheme is scheme_type::bfv each coefficient of a plaintext is a 64-bit word, but when the scheme is scheme_type::ckks the plaintext is by default stored in an NTT transformed form with respect to each of the primes in the coefficient modulus. Thus, the size of the allocation that is needed is the size of the coefficient modulus (number of primes) times the degree of the polynomial modulus. In addition, a valid CKKS plaintext also store the parms_id for the corresponding encryption parameters.</p>
<dl class="section user"><dt>Thread Safety</dt><dd>In general, reading from plaintext is thread-safe as long as no other thread is concurrently mutating it. This is due to the underlying data structure storing the plaintext not being thread-safe.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> for the class that stores ciphertexts. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac720e0a1a370ff93b623be748b166956" name="ac720e0a1a370ff93b623be748b166956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac720e0a1a370ff93b623be748b166956">&#9670;&#160;</a></span>Plaintext() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::Plaintext::Plaintext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an empty plaintext allocating no memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afaf15f02984276a0cd18ff823931f3f8" name="afaf15f02984276a0cd18ff823931f3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf15f02984276a0cd18ff823931f3f8">&#9670;&#160;</a></span>Plaintext() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::Plaintext::Plaintext </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>coeff_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a plaintext representing a constant polynomial 0. The coefficient count of the polynomial is set to the given value. The capacity is set to the same value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coeff_count</td><td>The number of (zeroed) coefficients in the plaintext polynomial </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if coeff_count is negative </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab82e65730322ba4de3906940223cc59b" name="ab82e65730322ba4de3906940223cc59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82e65730322ba4de3906940223cc59b">&#9670;&#160;</a></span>Plaintext() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::Plaintext::Plaintext </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>coeff_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a plaintext representing a constant polynomial 0. The coefficient count of the polynomial and the capacity are set to the given values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>The capacity </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coeff_count</td><td>The number of (zeroed) coefficients in the plaintext polynomial </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if capacity is less than coeff_count </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if coeff_count is negative </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01a6815db36aff2d7366d089cf4b0e2b" name="a01a6815db36aff2d7366d089cf4b0e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a6815db36aff2d7366d089cf4b0e2b">&#9670;&#160;</a></span>Plaintext() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::Plaintext::Plaintext </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hex_poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a plaintext from a given hexadecimal string describing the plaintext polynomial.</p>
<p>The string description of the polynomial must adhere to the format returned by <a class="el" href="classseal_1_1_plaintext.html#ad6ea95954eca1900072165cf7328e651">to_string()</a>, which is of the form "7FFx^3 + 1x^1 + 3" and summarized by the following rules:</p><ol type="1">
<li>Terms are listed in order of strictly decreasing exponent</li>
<li>Coefficient values are non-negative and in hexadecimal format (upper and lower case letters are both supported)</li>
<li>Exponents are positive and in decimal format</li>
<li>Zero coefficient terms (including the constant term) may be (but do not have to be) omitted</li>
<li>Term with the exponent value of one must be exactly written as x^1</li>
<li>Term with the exponent value of zero (the constant term) must be written as just a hexadecimal number without exponent</li>
<li>Terms must be separated by exactly &lt;space&gt;+&lt;space&gt; and minus is not allowed</li>
<li>Other than the +, no other terms should have whitespace</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hex_poly</td><td>The formatted polynomial string specifying the plaintext polynomial </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if hex_poly does not adhere to the expected format </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73d5a33b5f483f7036e77bdb5ecc3a0e" name="a73d5a33b5f483f7036e77bdb5ecc3a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d5a33b5f483f7036e77bdb5ecc3a0e">&#9670;&#160;</a></span>Plaintext() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::Plaintext::Plaintext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new plaintext by copying a given one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copy</td><td>The plaintext to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44b8a8a17ceb6f40c0f3af31d312652e" name="a44b8a8a17ceb6f40c0f3af31d312652e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b8a8a17ceb6f40c0f3af31d312652e">&#9670;&#160;</a></span>Plaintext() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::Plaintext::Plaintext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new plaintext by moving a given one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The plaintext to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa73f65284edf13cea0d1999f1ca535c1" name="aa73f65284edf13cea0d1999f1ca535c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73f65284edf13cea0d1999f1ca535c1">&#9670;&#160;</a></span>Plaintext() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::Plaintext::Plaintext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new plaintext by copying a given one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copy</td><td>The plaintext to copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad07f5bf2f7590622a033244ab67161b7" name="ad07f5bf2f7590622a033244ab67161b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07f5bf2f7590622a033244ab67161b7">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::size_t seal::Plaintext::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the capacity of the current allocation. </p>

</div>
</div>
<a id="aef4d6b331be5b87ffbaae9326fe2db53" name="aef4d6b331be5b87ffbaae9326fe2db53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4d6b331be5b87ffbaae9326fe2db53">&#9670;&#160;</a></span>coeff_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::size_t seal::Plaintext::coeff_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the coefficient count of the current plaintext polynomial. </p>

</div>
</div>
<a id="a3cc008a7387da45f5035d12fbb67936c" name="a3cc008a7387da45f5035d12fbb67936c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc008a7387da45f5035d12fbb67936c">&#9670;&#160;</a></span>data() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD pt_coeff_type * seal::Plaintext::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the beginning of the plaintext polynomial. </p>

</div>
</div>
<a id="a2717a53f84b96ddcfef454354ca8cd8a" name="a2717a53f84b96ddcfef454354ca8cd8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2717a53f84b96ddcfef454354ca8cd8a">&#9670;&#160;</a></span>data() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const pt_coeff_type * seal::Plaintext::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const pointer to the beginning of the plaintext polynomial. </p>

</div>
</div>
<a id="a8f89b3a748ad32983d8b3e41f97b4749" name="a8f89b3a748ad32983d8b3e41f97b4749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f89b3a748ad32983d8b3e41f97b4749">&#9670;&#160;</a></span>data() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD pt_coeff_type * seal::Plaintext::data </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>coeff_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to a given coefficient of the plaintext polynomial.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coeff_index</td><td>The index of the coefficient in the plaintext polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if coeff_index is not within [0, coeff_count) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ccb98bb396ca910b144b340a966c52e" name="a6ccb98bb396ca910b144b340a966c52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccb98bb396ca910b144b340a966c52e">&#9670;&#160;</a></span>data() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const pt_coeff_type * seal::Plaintext::data </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>coeff_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const pointer to a given coefficient of the plaintext polynomial.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coeff_index</td><td>The index of the coefficient in the plaintext polynomial </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87a83dbf94a51977c45412eb0cc760eb" name="a87a83dbf94a51977c45412eb0cc760eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a83dbf94a51977c45412eb0cc760eb">&#9670;&#160;</a></span>dyn_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const auto &amp; seal::Plaintext::dyn_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the backing <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> object. </p>

</div>
</div>
<a id="a7cf0a51529161f3fcd7cdcdd45d9171a" name="a7cf0a51529161f3fcd7cdcdd45d9171a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf0a51529161f3fcd7cdcdd45d9171a">&#9670;&#160;</a></span>is_ntt_form()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::Plaintext::is_ntt_form </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the plaintext is in NTT form. </p>

</div>
</div>
<a id="aabb309fcc897361c1371da08952b2867" name="aabb309fcc897361c1371da08952b2867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb309fcc897361c1371da08952b2867">&#9670;&#160;</a></span>is_zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::Plaintext::is_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the current plaintext polynomial has all zero coefficients. </p>

</div>
</div>
<a id="acc8c2c4a470fd028c9e78ccdd9942b98" name="acc8c2c4a470fd028c9e78ccdd9942b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8c2c4a470fd028c9e78ccdd9942b98">&#9670;&#160;</a></span>load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff seal::Plaintext::load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const seal_byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads a plaintext from an input stream overwriting the current plaintext. The loaded plaintext is verified to be valid for the given <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>The memory location to load the <a class="el" href="classseal_1_1_public_key.html">PublicKey</a> from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes available in the given memory location </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if in is null or if size is too small to contain a SEALHeader </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the data cannot be loaded by this version of Microsoft SEAL, if the loaded data is invalid, or if decompression failed </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if I/O operations failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26893c6ce73355e3d69a869b8e5455bc" name="a26893c6ce73355e3d69a869b8e5455bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26893c6ce73355e3d69a869b8e5455bc">&#9670;&#160;</a></span>load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff seal::Plaintext::load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads a plaintext from an input stream overwriting the current plaintext. The loaded plaintext is verified to be valid for the given <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream to load the plaintext from </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the data cannot be loaded by this version of Microsoft SEAL, if the loaded data is invalid, or if decompression failed </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if I/O operations failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a607f4416dd7c7acc58ccd277e9878376" name="a607f4416dd7c7acc58ccd277e9878376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607f4416dd7c7acc58ccd277e9878376">&#9670;&#160;</a></span>nonzero_coeff_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::size_t seal::Plaintext::nonzero_coeff_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the non-zero coefficient count of the current plaintext polynomial. </p>

</div>
</div>
<a id="ab77c067cd07a16c7e29b97fc6d886e97" name="ab77c067cd07a16c7e29b97fc6d886e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77c067cd07a16c7e29b97fc6d886e97">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::Plaintext::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not the plaintext has a different semantic value than a given plaintext. Leading zero coefficients are ignored by the comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>The plaintext to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32b8be6d4882f1d0933aecb7362f4828" name="a32b8be6d4882f1d0933aecb7362f4828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b8be6d4882f1d0933aecb7362f4828">&#9670;&#160;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp; seal::Plaintext::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>assign</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies a given plaintext to the current one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">assign</td><td>The plaintext to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f2830894c1f852b0955a7c637299aea" name="a3f2830894c1f852b0955a7c637299aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2830894c1f852b0955a7c637299aea">&#9670;&#160;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp; seal::Plaintext::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hex_poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the value of the current plaintext to the polynomial represented by the given hexadecimal string.</p>
<p>The string description of the polynomial must adhere to the format returned by <a class="el" href="classseal_1_1_plaintext.html#ad6ea95954eca1900072165cf7328e651">to_string()</a>, which is of the form "7FFx^3 + 1x^1 + 3" and summarized by the following rules:</p><ol type="1">
<li>Terms are listed in order of strictly decreasing exponent</li>
<li>Coefficient values are non-negative and in hexadecimal format (upper and lower case letters are both supported)</li>
<li>Exponents are positive and in decimal format</li>
<li>Zero coefficient terms (including the constant term) may be (but do not have to be) omitted</li>
<li>Term with the exponent value of one must be exactly written as x^1</li>
<li>Term with the exponent value of zero (the constant term) must be written as just a hexadecimal number without exponent</li>
<li>Terms must be separated by exactly &lt;space&gt;+&lt;space&gt; and minus is not allowed</li>
<li>Other than the +, no other terms should have whitespace</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hex_poly</td><td>The formatted polynomial string specifying the plaintext polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if hex_poly does not adhere to the expected format </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the coefficients of hex_poly are too wide </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13ce7cc2bee62b8525f1d063e1605507" name="a13ce7cc2bee62b8525f1d063e1605507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ce7cc2bee62b8525f1d063e1605507">&#9670;&#160;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp; seal::Plaintext::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>assign</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Moves a given plaintext to the current one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">assign</td><td>The plaintext to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affa58981ed6d6128f30e751c836cd779" name="affa58981ed6d6128f30e751c836cd779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa58981ed6d6128f30e751c836cd779">&#9670;&#160;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp; seal::Plaintext::operator= </td>
          <td>(</td>
          <td class="paramtype">pt_coeff_type&#160;</td>
          <td class="paramname"><em>const_coeff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the value of the current plaintext to a given constant polynomial and sets the parms_id to parms_id_zero, effectively marking the plaintext as not NTT transformed. The coefficient count is set to one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">const_coeff</td><td>The constant coefficient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d192324435bc7e237756df3566fc1c3" name="a1d192324435bc7e237756df3566fc1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d192324435bc7e237756df3566fc1c3">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::Plaintext::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether or not the plaintext has the same semantic value as a given plaintext. Leading zero coefficients are ignored by the comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>The plaintext to compare against </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac49357382074eff559e0d43a48559f7d" name="ac49357382074eff559e0d43a48559f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49357382074eff559e0d43a48559f7d">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD pt_coeff_type &amp; seal::Plaintext::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>coeff_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to a given coefficient of the plaintext polynomial.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coeff_index</td><td>The index of the coefficient in the plaintext polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if coeff_index is not within [0, coeff_count) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fea06a4e0d493a6f9813007b5c74743" name="a6fea06a4e0d493a6f9813007b5c74743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fea06a4e0d493a6f9813007b5c74743">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const pt_coeff_type &amp; seal::Plaintext::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>coeff_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const reference to a given coefficient of the plaintext polynomial.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coeff_index</td><td>The index of the coefficient in the plaintext polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if coeff_index is not within [0, coeff_count) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02c3e309fcfa4648a3df2539d69facd1" name="a02c3e309fcfa4648a3df2539d69facd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c3e309fcfa4648a3df2539d69facd1">&#9670;&#160;</a></span>parms_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const parms_id_type &amp; seal::Plaintext::parms_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const reference to parms_id. The parms_id must remain zero unless the plaintext polynomial is in NTT form.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1_encryption_parameters.html">EncryptionParameters</a> for more information about <a class="el" href="classseal_1_1_plaintext.html#af643a3b656727d350ed3206ea65adf40">parms_id</a>. </dd></dl>

</div>
</div>
<a id="af643a3b656727d350ed3206ea65adf40" name="af643a3b656727d350ed3206ea65adf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af643a3b656727d350ed3206ea65adf40">&#9670;&#160;</a></span>parms_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD parms_id_type &amp; seal::Plaintext::parms_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to parms_id. The parms_id must remain zero unless the plaintext polynomial is in NTT form.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1_encryption_parameters.html">EncryptionParameters</a> for more information about <a class="el" href="classseal_1_1_plaintext.html#af643a3b656727d350ed3206ea65adf40">parms_id</a>. </dd></dl>

</div>
</div>
<a id="a00ebd136a670476537c5941e99a80e33" name="a00ebd136a670476537c5941e99a80e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ebd136a670476537c5941e99a80e33">&#9670;&#160;</a></span>pool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> seal::Plaintext::pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the currently used <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>. </p>

</div>
</div>
<a id="a29c2b6a99a59b09c21c77eee8075d3f8" name="a29c2b6a99a59b09c21c77eee8075d3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c2b6a99a59b09c21c77eee8075d3f8">&#9670;&#160;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Plaintext::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets the plaintext. This function releases any memory allocated by the plaintext, returning it to the memory pool. </p>

</div>
</div>
<a id="acb33767af974ef6d9996956ccf76b977" name="acb33767af974ef6d9996956ccf76b977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb33767af974ef6d9996956ccf76b977">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Plaintext::reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates enough memory to accommodate the backing array of a plaintext with given capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>The capacity </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if capacity is negative </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the plaintext is NTT transformed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af10c6e3e01730199d2cddfdca480e039" name="af10c6e3e01730199d2cddfdca480e039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10c6e3e01730199d2cddfdca480e039">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Plaintext::resize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>coeff_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the plaintext to have a given coefficient count. The plaintext is automatically reallocated if the new coefficient count does not fit in the current capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coeff_count</td><td>The number of coefficients in the plaintext polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if coeff_count is negative </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the plaintext is NTT transformed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb65a3de6a3d6d71e5c1c80919eea60f" name="abb65a3de6a3d6d71e5c1c80919eea60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb65a3de6a3d6d71e5c1c80919eea60f">&#9670;&#160;</a></span>save() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff seal::Plaintext::save </td>
          <td>(</td>
          <td class="paramtype">seal_byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compr_mode_type&#160;</td>
          <td class="paramname"><em>compr_mode</em> = <code><a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves the plaintext to a given memory location. The output is in binary format and not human-readable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>The memory location to write the plaintext to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes available in the given memory location </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compr_mode</td><td>The desired compression mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if out is null or if size is too small to contain a SEALHeader, or if the compression mode is not supported </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the data to be saved is invalid, or if compression failed </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if I/O operations failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e5136783dde07fde0b4c76acc01422e" name="a4e5136783dde07fde0b4c76acc01422e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5136783dde07fde0b4c76acc01422e">&#9670;&#160;</a></span>save() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff seal::Plaintext::save </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compr_mode_type&#160;</td>
          <td class="paramname"><em>compr_mode</em> = <code><a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves the plaintext to an output stream. The output is in binary format and not human-readable. The output stream must have the "binary" flag set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stream</td><td>The stream to save the plaintext to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compr_mode</td><td>The desired compression mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the compression mode is not supported </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the data to be saved is invalid, or if compression failed </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if I/O operations failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac601de584be9f7d4d96543fcb47868a6" name="ac601de584be9f7d4d96543fcb47868a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac601de584be9f7d4d96543fcb47868a6">&#9670;&#160;</a></span>save_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::streamoff seal::Plaintext::save_size </td>
          <td>(</td>
          <td class="paramtype">compr_mode_type&#160;</td>
          <td class="paramname"><em>compr_mode</em> = <code><a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an upper bound on the size of the plaintext, as if it was written to an output stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compr_mode</td><td>The compression mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the compression mode is not supported </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the size does not fit in the return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a664bfea6515b3a3da420f431f451b6" name="a1a664bfea6515b3a3da420f431f451b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a664bfea6515b3a3da420f431f451b6">&#9670;&#160;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const double &amp; seal::Plaintext::scale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant reference to the scale. This is only needed when using the CKKS encryption scheme. </p>

</div>
</div>
<a id="a958fcd7c2bb3b1efc8bc8ccb1c6dc575" name="a958fcd7c2bb3b1efc8bc8ccb1c6dc575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958fcd7c2bb3b1efc8bc8ccb1c6dc575">&#9670;&#160;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD double &amp; seal::Plaintext::scale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the scale. This is only needed when using the CKKS encryption scheme. The user should have little or no reason to ever change the scale by hand. </p>

</div>
</div>
<a id="adbe996fc6fc8a5296a7b242d260f7003" name="adbe996fc6fc8a5296a7b242d260f7003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe996fc6fc8a5296a7b242d260f7003">&#9670;&#160;</a></span>set_zero() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Plaintext::set_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the plaintext polynomial to zero. </p>

</div>
</div>
<a id="adb0b8c48042aa5b0a992f3008ea50d66" name="adb0b8c48042aa5b0a992f3008ea50d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0b8c48042aa5b0a992f3008ea50d66">&#9670;&#160;</a></span>set_zero() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Plaintext::set_zero </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>start_coeff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the plaintext polynomial coefficients to zero starting at a given index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start_coeff</td><td>The index of the first coefficient to set to zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if start_coeff is not within [0, coeff_count) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2539b60c9a71d6e32dce953b62ecd0d1" name="a2539b60c9a71d6e32dce953b62ecd0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2539b60c9a71d6e32dce953b62ecd0d1">&#9670;&#160;</a></span>set_zero() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Plaintext::set_zero </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>start_coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a given range of coefficients of a plaintext polynomial to zero; does nothing if length is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start_coeff</td><td>The index of the first coefficient to set to zero </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of coefficients to set to zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if start_coeff + length - 1 is not within [0, coeff_count) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9da5b93c14bbf3be8eef7276e8852f7" name="af9da5b93c14bbf3be8eef7276e8852f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9da5b93c14bbf3be8eef7276e8852f7">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Plaintext::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates enough memory to accommodate the backing array of the current plaintext and copies it over to the new location. This function is meant to reduce the memory use of the plaintext to smallest possible and can be particularly important after modulus switching. </p>

</div>
</div>
<a id="aad488313cf7e15eb3be0327b3b896072" name="aad488313cf7e15eb3be0327b3b896072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad488313cf7e15eb3be0327b3b896072">&#9670;&#160;</a></span>significant_coeff_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::size_t seal::Plaintext::significant_coeff_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the significant coefficient count of the current plaintext polynomial. </p>

</div>
</div>
<a id="ad6ea95954eca1900072165cf7328e651" name="ad6ea95954eca1900072165cf7328e651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ea95954eca1900072165cf7328e651">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::string seal::Plaintext::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a human-readable string description of the plaintext polynomial.</p>
<p>The returned string is of the form "7FFx^3 + 1x^1 + 3" with a format summarized by the following:</p><ol type="1">
<li>Terms are listed in order of strictly decreasing exponent</li>
<li>Coefficient values are non-negative and in hexadecimal format (hexadecimal letters are in upper-case)</li>
<li>Exponents are positive and in decimal format</li>
<li>Zero coefficient terms (including the constant term) are omitted unless the polynomial is exactly 0 (see rule 9)</li>
<li>Term with the exponent value of one is written as x^1</li>
<li>Term with the exponent value of zero (the constant term) is written as just a hexadecimal number without x or exponent</li>
<li>Terms are separated exactly by &lt;space&gt;+&lt;space&gt;</li>
<li>Other than the +, no other terms have whitespace</li>
<li>If the polynomial is exactly 0, the string "0" is returned</li>
</ol>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the plaintext is in NTT transformed form </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0c306c36d377d91359b4041402a9fbe" name="ab0c306c36d377d91359b4041402a9fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c306c36d377d91359b4041402a9fbe">&#9670;&#160;</a></span>unsafe_load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff seal::Plaintext::unsafe_load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const seal_byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads a plaintext from a given memory location overwriting the current plaintext. No checking of the validity of the plaintext data against encryption parameters is performed. This function should not be used unless the plaintext comes from a fully trusted source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>The memory location to load the plaintext from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes available in the given memory location </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if in is null or if size is too small to contain a SEALHeader </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the data cannot be loaded by this version of Microsoft SEAL, if the loaded data is invalid, or if decompression failed </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if I/O operations failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c6ded783346dda1fed68ecbd575cb76" name="a4c6ded783346dda1fed68ecbd575cb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6ded783346dda1fed68ecbd575cb76">&#9670;&#160;</a></span>unsafe_load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff seal::Plaintext::unsafe_load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads a plaintext from an input stream overwriting the current plaintext. No checking of the validity of the plaintext data against encryption parameters is performed. This function should not be used unless the plaintext comes from a fully trusted source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream to load the plaintext from </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the data cannot be loaded by this version of Microsoft SEAL, if the loaded data is invalid, or if decompression failed </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if I/O operations failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>seal/<a class="el" href="plaintext_8h_source.html">plaintext.h</a></li>
<li>seal/plaintext.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
