<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEAL: seal::KeyGenerator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SEAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>seal</b></li><li class="navelem"><a class="el" href="classseal_1_1_key_generator.html">KeyGenerator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseal_1_1_key_generator-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">seal::KeyGenerator Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="keygenerator_8h_source.html">keygenerator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5ec9f1662d39c64fef283087e8fd6f4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_key_generator.html#a5ec9f1662d39c64fef283087e8fd6f4b">KeyGenerator</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context)</td></tr>
<tr class="separator:a5ec9f1662d39c64fef283087e8fd6f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbde4fe8c1a6418445ce99b1cdd4844"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_key_generator.html#a5dbde4fe8c1a6418445ce99b1cdd4844">KeyGenerator</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, const <a class="el" href="classseal_1_1_secret_key.html">SecretKey</a> &amp;<a class="el" href="classseal_1_1_key_generator.html#abe5959387396b30eac12f840a00167c9">secret_key</a>)</td></tr>
<tr class="separator:a5dbde4fe8c1a6418445ce99b1cdd4844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5959387396b30eac12f840a00167c9"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const <a class="el" href="classseal_1_1_secret_key.html">SecretKey</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_key_generator.html#abe5959387396b30eac12f840a00167c9">secret_key</a> () const</td></tr>
<tr class="separator:abe5959387396b30eac12f840a00167c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb648691b1525d6ae8672fe4fd995d97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_key_generator.html#adb648691b1525d6ae8672fe4fd995d97">create_public_key</a> (<a class="el" href="classseal_1_1_public_key.html">PublicKey</a> &amp;destination) const</td></tr>
<tr class="separator:adb648691b1525d6ae8672fe4fd995d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18af85a29809e4bc6aceb9b8f5ef6eee"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_public_key.html">PublicKey</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_key_generator.html#a18af85a29809e4bc6aceb9b8f5ef6eee">create_public_key</a> () const</td></tr>
<tr class="separator:a18af85a29809e4bc6aceb9b8f5ef6eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290b17b3c57cf38b0b9b4b88e9de9be9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_key_generator.html#a290b17b3c57cf38b0b9b4b88e9de9be9">create_relin_keys</a> (<a class="el" href="classseal_1_1_relin_keys.html">RelinKeys</a> &amp;destination)</td></tr>
<tr class="separator:a290b17b3c57cf38b0b9b4b88e9de9be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae856a44a71033aa0e2dfdd0f2a6e23d8"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_relin_keys.html">RelinKeys</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_key_generator.html#ae856a44a71033aa0e2dfdd0f2a6e23d8">create_relin_keys</a> ()</td></tr>
<tr class="separator:ae856a44a71033aa0e2dfdd0f2a6e23d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a07675f41a896ebe06b887ad0a8ddb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_key_generator.html#a18a07675f41a896ebe06b887ad0a8ddb">create_galois_keys</a> (const std::vector&lt; std::uint32_t &gt; &amp;galois_elts, <a class="el" href="classseal_1_1_galois_keys.html">GaloisKeys</a> &amp;destination)</td></tr>
<tr class="separator:a18a07675f41a896ebe06b887ad0a8ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0378537547083a95b53c7822911cfd89"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_galois_keys.html">GaloisKeys</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_key_generator.html#a0378537547083a95b53c7822911cfd89">create_galois_keys</a> (const std::vector&lt; std::uint32_t &gt; &amp;galois_elts)</td></tr>
<tr class="separator:a0378537547083a95b53c7822911cfd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38c9850fc70741799c945deca773499"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_key_generator.html#ad38c9850fc70741799c945deca773499">create_galois_keys</a> (const std::vector&lt; int &gt; &amp;steps, <a class="el" href="classseal_1_1_galois_keys.html">GaloisKeys</a> &amp;destination)</td></tr>
<tr class="separator:ad38c9850fc70741799c945deca773499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeac514be5087ee9a3d936e6de6f5773"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_galois_keys.html">GaloisKeys</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_key_generator.html#afeac514be5087ee9a3d936e6de6f5773">create_galois_keys</a> (const std::vector&lt; int &gt; &amp;steps)</td></tr>
<tr class="separator:afeac514be5087ee9a3d936e6de6f5773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa156a9f6bfb8ebf9490428ca5c0de81c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_key_generator.html#aa156a9f6bfb8ebf9490428ca5c0de81c">create_galois_keys</a> (<a class="el" href="classseal_1_1_galois_keys.html">GaloisKeys</a> &amp;destination)</td></tr>
<tr class="separator:aa156a9f6bfb8ebf9490428ca5c0de81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e08d7080937598007af08b797cd83a"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_galois_keys.html">GaloisKeys</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_key_generator.html#ad7e08d7080937598007af08b797cd83a">create_galois_keys</a> ()</td></tr>
<tr class="separator:ad7e08d7080937598007af08b797cd83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generates matching secret key and public key. An existing <a class="el" href="classseal_1_1_key_generator.html">KeyGenerator</a> can also at any time be used to generate relinearization keys and Galois keys. Constructing a <a class="el" href="classseal_1_1_key_generator.html">KeyGenerator</a> requires only a <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1_encryption_parameters.html">EncryptionParameters</a> for more details on encryption parameters. </dd>
<dd>
<a class="el" href="classseal_1_1_secret_key.html">SecretKey</a> for more details on secret key. </dd>
<dd>
<a class="el" href="classseal_1_1_public_key.html">PublicKey</a> for more details on public key. </dd>
<dd>
<a class="el" href="classseal_1_1_relin_keys.html">RelinKeys</a> for more details on relinearization keys. </dd>
<dd>
<a class="el" href="classseal_1_1_galois_keys.html">GaloisKeys</a> for more details on Galois keys. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5ec9f1662d39c64fef283087e8fd6f4b" name="a5ec9f1662d39c64fef283087e8fd6f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec9f1662d39c64fef283087e8fd6f4b">&#9670;&#160;</a></span>KeyGenerator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">seal::KeyGenerator::KeyGenerator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classseal_1_1_key_generator.html">KeyGenerator</a> initialized with the specified <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dbde4fe8c1a6418445ce99b1cdd4844" name="a5dbde4fe8c1a6418445ce99b1cdd4844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbde4fe8c1a6418445ce99b1cdd4844">&#9670;&#160;</a></span>KeyGenerator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">seal::KeyGenerator::KeyGenerator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_secret_key.html">SecretKey</a> &amp;&#160;</td>
          <td class="paramname"><em>secret_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an <a class="el" href="classseal_1_1_key_generator.html">KeyGenerator</a> instance initialized with the specified <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> and specified previously secret key. This can e.g. be used to increase the number of relinearization keys from what had earlier been generated, or to generate Galois keys in case they had not been generated earlier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secret_key</td><td>A previously generated secret key </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if secret_key is not valid for encryption parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad7e08d7080937598007af08b797cd83a" name="ad7e08d7080937598007af08b797cd83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e08d7080937598007af08b797cd83a">&#9670;&#160;</a></span>create_galois_keys() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_galois_keys.html">GaloisKeys</a> &gt; seal::KeyGenerator::create_galois_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates and returns Galois keys as a serializable object. Every time this function is called, new Galois keys will be generated.</p>
<p>Half of the key data is pseudo-randomly generated from a seed to reduce the object size. The resulting serializable object cannot be used directly and is meant to be serialized for the size reduction to have an impact.</p>
<p>This function creates logarithmically many (in degree of the polynomial modulus) Galois keys that is sufficient to apply any Galois automorphism (e.g., rotations) on encrypted data. Most users will want to use this overload of the function.</p>
<p>Precisely it generates 2*log(n)-1 number of Galois keys where n is the degree of the polynomial modulus. When used with batching, these keys support direct left and right rotations of power-of-2 steps of rows in BFV or vectors in CKKS and rotation of columns in BFV or conjugation in CKKS.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the encryption parameters do not support keyswitching </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afeac514be5087ee9a3d936e6de6f5773" name="afeac514be5087ee9a3d936e6de6f5773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeac514be5087ee9a3d936e6de6f5773">&#9670;&#160;</a></span>create_galois_keys() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_galois_keys.html">GaloisKeys</a> &gt; seal::KeyGenerator::create_galois_keys </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>steps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates and returns Galois keys as a serializable object. Every time this function is called, new Galois keys will be generated.</p>
<p>Half of the key data is pseudo-randomly generated from a seed to reduce the object size. The resulting serializable object cannot be used directly and is meant to be serialized for the size reduction to have an impact.</p>
<p>The user needs to give as input a vector of desired Galois rotation step counts, where negative step counts correspond to rotations to the right and positive step counts correspond to rotations to the left. A step count of zero can be used to indicate a column rotation in the BFV scheme and complex conjugation in the CKKS scheme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">steps</td><td>The rotation step counts for which to generate keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the encryption parameters do not support batching and scheme is scheme_type::BFV </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the encryption parameters do not support keyswitching </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the step counts are not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad38c9850fc70741799c945deca773499" name="ad38c9850fc70741799c945deca773499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38c9850fc70741799c945deca773499">&#9670;&#160;</a></span>create_galois_keys() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::KeyGenerator::create_galois_keys </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_galois_keys.html">GaloisKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates Galois keys and stores the result in destination. Every time this function is called, new Galois keys will be generated.</p>
<p>The user needs to give as input a vector of desired Galois rotation step counts, where negative step counts correspond to rotations to the right and positive step counts correspond to rotations to the left. A step count of zero can be used to indicate a column rotation in the BFV scheme and complex conjugation in the CKKS scheme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">steps</td><td>The rotation step counts for which to generate keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The Galois keys to overwrite with the generated Galois keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the encryption parameters do not support batching and scheme is scheme_type::BFV </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the encryption parameters do not support keyswitching </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the step counts are not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0378537547083a95b53c7822911cfd89" name="a0378537547083a95b53c7822911cfd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0378537547083a95b53c7822911cfd89">&#9670;&#160;</a></span>create_galois_keys() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_galois_keys.html">GaloisKeys</a> &gt; seal::KeyGenerator::create_galois_keys </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>galois_elts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates and returns Galois keys as a serializable object. Every time this function is called, new Galois keys will be generated.</p>
<p>Half of the key data is pseudo-randomly generated from a seed to reduce the object size. The resulting serializable object cannot be used directly and is meant to be serialized for the size reduction to have an impact.</p>
<p>This function creates specific Galois keys that can be used to apply specific Galois automorphisms on encrypted data. The user needs to give as input a vector of Galois elements corresponding to the keys that are to be created.</p>
<p>The Galois elements are odd integers in the interval [1, M-1], where M = 2*N, and N = poly_modulus_degree. Used with batching, a Galois element 3^i % M corresponds to a cyclic row rotation i steps to the left, and a Galois element 3^(N/2-i) % M corresponds to a cyclic row rotation i steps to the right. The Galois element M-1 corresponds to a column rotation (row swap) in BFV, and complex conjugation in CKKS. In the polynomial view (not batching), a Galois automorphism by a Galois element p changes Enc(plain(x)) to Enc(plain(x^p)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">galois_elts</td><td>The Galois elements for which to generate keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the encryption parameters do not support keyswitching </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the Galois elements are not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18a07675f41a896ebe06b887ad0a8ddb" name="a18a07675f41a896ebe06b887ad0a8ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a07675f41a896ebe06b887ad0a8ddb">&#9670;&#160;</a></span>create_galois_keys() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::KeyGenerator::create_galois_keys </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>galois_elts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_galois_keys.html">GaloisKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates Galois keys and stores the result in destination. Every time this function is called, new Galois keys will be generated.</p>
<p>This function creates specific Galois keys that can be used to apply specific Galois automorphisms on encrypted data. The user needs to give as input a vector of Galois elements corresponding to the keys that are to be created.</p>
<p>The Galois elements are odd integers in the interval [1, M-1], where M = 2*N, and N = poly_modulus_degree. Used with batching, a Galois element 3^i % M corresponds to a cyclic row rotation i steps to the left, and a Galois element 3^(N/2-i) % M corresponds to a cyclic row rotation i steps to the right. The Galois element M-1 corresponds to a column rotation (row swap) in BFV, and complex conjugation in CKKS. In the polynomial view (not batching), a Galois automorphism by a Galois element p changes Enc(plain(x)) to Enc(plain(x^p)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">galois_elts</td><td>The Galois elements for which to generate keys </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The Galois keys to overwrite with the generated Galois keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the encryption parameters do not support keyswitching </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the Galois elements are not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa156a9f6bfb8ebf9490428ca5c0de81c" name="aa156a9f6bfb8ebf9490428ca5c0de81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa156a9f6bfb8ebf9490428ca5c0de81c">&#9670;&#160;</a></span>create_galois_keys() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::KeyGenerator::create_galois_keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1_galois_keys.html">GaloisKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates Galois keys and stores the result in destination. Every time this function is called, new Galois keys will be generated.</p>
<p>This function creates logarithmically many (in degree of the polynomial modulus) Galois keys that is sufficient to apply any Galois automorphism (e.g., rotations) on encrypted data. Most users will want to use this overload of the function.</p>
<p>Precisely it generates 2*log(n)-1 number of Galois keys where n is the degree of the polynomial modulus. When used with batching, these keys support direct left and right rotations of power-of-2 steps of rows in BFV or vectors in CKKS and rotation of columns in BFV or conjugation in CKKS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The Galois keys to overwrite with the generated Galois keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the encryption parameters do not support keyswitching </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18af85a29809e4bc6aceb9b8f5ef6eee" name="a18af85a29809e4bc6aceb9b8f5ef6eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18af85a29809e4bc6aceb9b8f5ef6eee">&#9670;&#160;</a></span>create_public_key() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_public_key.html">PublicKey</a> &gt; seal::KeyGenerator::create_public_key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates and returns a public key as a serializable object. Every time this function is called, a new public key will be generated.</p>
<p>Half of the key data is pseudo-randomly generated from a seed to reduce the object size. The resulting serializable object cannot be used directly and is meant to be serialized for the size reduction to have an impact. </p>

</div>
</div>
<a id="adb648691b1525d6ae8672fe4fd995d97" name="adb648691b1525d6ae8672fe4fd995d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb648691b1525d6ae8672fe4fd995d97">&#9670;&#160;</a></span>create_public_key() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::KeyGenerator::create_public_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1_public_key.html">PublicKey</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a public key and stores the result in destination. Every time this function is called, a new public key will be generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The public key to overwrite with the generated public key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae856a44a71033aa0e2dfdd0f2a6e23d8" name="ae856a44a71033aa0e2dfdd0f2a6e23d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae856a44a71033aa0e2dfdd0f2a6e23d8">&#9670;&#160;</a></span>create_relin_keys() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1_serializable.html">Serializable</a>&lt; <a class="el" href="classseal_1_1_relin_keys.html">RelinKeys</a> &gt; seal::KeyGenerator::create_relin_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates and returns relinearization keys as a serializable object. Every time this function is called, new relinearization keys will be generated.</p>
<p>Half of the key data is pseudo-randomly generated from a seed to reduce the object size. The resulting serializable object cannot be used directly and is meant to be serialized for the size reduction to have an impact.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the encryption parameters do not support keyswitching </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a290b17b3c57cf38b0b9b4b88e9de9be9" name="a290b17b3c57cf38b0b9b4b88e9de9be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290b17b3c57cf38b0b9b4b88e9de9be9">&#9670;&#160;</a></span>create_relin_keys() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::KeyGenerator::create_relin_keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1_relin_keys.html">RelinKeys</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates relinearization keys and stores the result in destination. Every time this function is called, new relinearization keys will be generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The relinearization keys to overwrite with the generated relinearization keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the encryption parameters do not support keyswitching </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe5959387396b30eac12f840a00167c9" name="abe5959387396b30eac12f840a00167c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5959387396b30eac12f840a00167c9">&#9670;&#160;</a></span>secret_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classseal_1_1_secret_key.html">SecretKey</a> &amp; seal::KeyGenerator::secret_key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a const reference to the secret key. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>seal/<a class="el" href="keygenerator_8h_source.html">keygenerator.h</a></li>
<li>seal/keygenerator.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
