<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEAL: seal::DynArray&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SEAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>seal</b></li><li class="navelem"><a class="el" href="classseal_1_1_dyn_array.html">DynArray</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classseal_1_1_dyn_array-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">seal::DynArray&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="dynarray_8h_source.html">dynarray.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5693fd2c31266cc6cf444b206107fa13"><td class="memItemLeft" align="right" valign="top"><a id="a5693fd2c31266cc6cf444b206107fa13" name="a5693fd2c31266cc6cf444b206107fa13"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>type</b> = T</td></tr>
<tr class="separator:a5693fd2c31266cc6cf444b206107fa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a96556491782dd58d70c52b8ac1a50349"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a96556491782dd58d70c52b8ac1a50349">DynArray</a> (<a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1_dyn_array.html#acf03d26dba3486c2ef847fe21e45186d">pool</a>=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a96556491782dd58d70c52b8ac1a50349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790e24c14510af175423542a804be54f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a790e24c14510af175423542a804be54f">DynArray</a> (std::size_t <a class="el" href="classseal_1_1_dyn_array.html#ac458c4732f4f2ed188939f9ac5811fc5">size</a>, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1_dyn_array.html#acf03d26dba3486c2ef847fe21e45186d">pool</a>=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a790e24c14510af175423542a804be54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8184176f2dabccdc2d58dffde65489b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#ab8184176f2dabccdc2d58dffde65489b">DynArray</a> (std::size_t <a class="el" href="classseal_1_1_dyn_array.html#a2e78165db877ece7dc8560d40104c010">capacity</a>, std::size_t <a class="el" href="classseal_1_1_dyn_array.html#ac458c4732f4f2ed188939f9ac5811fc5">size</a>, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1_dyn_array.html#acf03d26dba3486c2ef847fe21e45186d">pool</a>=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:ab8184176f2dabccdc2d58dffde65489b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6986a196edb3e1da2398483da229ad1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a6986a196edb3e1da2398483da229ad1b">DynArray</a> (<a class="el" href="classseal_1_1util_1_1_pointer.html">util::Pointer</a>&lt; T &gt; &amp;&amp;ptr, std::size_t <a class="el" href="classseal_1_1_dyn_array.html#a2e78165db877ece7dc8560d40104c010">capacity</a>, std::size_t <a class="el" href="classseal_1_1_dyn_array.html#ac458c4732f4f2ed188939f9ac5811fc5">size</a>, bool fill_zero, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1_dyn_array.html#acf03d26dba3486c2ef847fe21e45186d">pool</a>=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a6986a196edb3e1da2398483da229ad1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd10b07a35df13a3f3da9a32434fabf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a5bd10b07a35df13a3f3da9a32434fabf">DynArray</a> (<a class="el" href="classseal_1_1util_1_1_pointer.html">util::Pointer</a>&lt; T &gt; &amp;&amp;ptr, std::size_t <a class="el" href="classseal_1_1_dyn_array.html#ac458c4732f4f2ed188939f9ac5811fc5">size</a>, bool fill_zero, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1_dyn_array.html#acf03d26dba3486c2ef847fe21e45186d">pool</a>=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a5bd10b07a35df13a3f3da9a32434fabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31f7f63760a708c8c21da9cdf4ae610"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#ae31f7f63760a708c8c21da9cdf4ae610">DynArray</a> (const <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>&lt; T &gt; &amp;copy)</td></tr>
<tr class="separator:ae31f7f63760a708c8c21da9cdf4ae610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6484fb984bd4d244bf4cb36c5a7aaa0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#af6484fb984bd4d244bf4cb36c5a7aaa0">DynArray</a> (<a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>&lt; T &gt; &amp;&amp;source) noexcept</td></tr>
<tr class="separator:af6484fb984bd4d244bf4cb36c5a7aaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8871bb4d14ad06653d483355c0acaa0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#af8871bb4d14ad06653d483355c0acaa0">~DynArray</a> ()</td></tr>
<tr class="separator:af8871bb4d14ad06653d483355c0acaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae36122e91c1b98e587ee267cdbe4247"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#aae36122e91c1b98e587ee267cdbe4247">begin</a> () noexcept</td></tr>
<tr class="separator:aae36122e91c1b98e587ee267cdbe4247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcf3ed42d037dd152f1bf0728530d3e"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a2fcf3ed42d037dd152f1bf0728530d3e">begin</a> () const noexcept</td></tr>
<tr class="separator:a2fcf3ed42d037dd152f1bf0728530d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6614fb84d8a226863b9f72ab39afd552"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a6614fb84d8a226863b9f72ab39afd552">cbegin</a> () const noexcept</td></tr>
<tr class="separator:a6614fb84d8a226863b9f72ab39afd552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7a4c43eec9ea5121dd095b9171fea4"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#afe7a4c43eec9ea5121dd095b9171fea4">end</a> () noexcept</td></tr>
<tr class="separator:afe7a4c43eec9ea5121dd095b9171fea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd88e79be1623df2f792299ba8a08b7"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a7bd88e79be1623df2f792299ba8a08b7">end</a> () const noexcept</td></tr>
<tr class="separator:a7bd88e79be1623df2f792299ba8a08b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78708e046c2d3a3f6dc3593b2b85a024"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a78708e046c2d3a3f6dc3593b2b85a024">cend</a> () const noexcept</td></tr>
<tr class="separator:a78708e046c2d3a3f6dc3593b2b85a024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a6d5c16f475d2f2d620dc27f04162a"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a10a6d5c16f475d2f2d620dc27f04162a">at</a> (std::size_t index) const</td></tr>
<tr class="separator:a10a6d5c16f475d2f2d620dc27f04162a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9b85469b05a97fac16ef64c62ba9c3"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a4c9b85469b05a97fac16ef64c62ba9c3">at</a> (std::size_t index)</td></tr>
<tr class="separator:a4c9b85469b05a97fac16ef64c62ba9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c81dd214d1c6c00a30e4d51c78ce9d9"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a4c81dd214d1c6c00a30e4d51c78ce9d9">operator[]</a> (std::size_t index) const</td></tr>
<tr class="separator:a4c81dd214d1c6c00a30e4d51c78ce9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e667d02a8b7a15c3b73003ffb90074"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#ac9e667d02a8b7a15c3b73003ffb90074">operator[]</a> (std::size_t index)</td></tr>
<tr class="separator:ac9e667d02a8b7a15c3b73003ffb90074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ab55f17cd7c081f7fde46f2567d2d2"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#ad8ab55f17cd7c081f7fde46f2567d2d2">empty</a> () const noexcept</td></tr>
<tr class="separator:ad8ab55f17cd7c081f7fde46f2567d2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749961e05095219111badffa70cd86f2"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a749961e05095219111badffa70cd86f2">max_size</a> () const noexcept</td></tr>
<tr class="separator:a749961e05095219111badffa70cd86f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac458c4732f4f2ed188939f9ac5811fc5"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#ac458c4732f4f2ed188939f9ac5811fc5">size</a> () const noexcept</td></tr>
<tr class="separator:ac458c4732f4f2ed188939f9ac5811fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e78165db877ece7dc8560d40104c010"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a2e78165db877ece7dc8560d40104c010">capacity</a> () const noexcept</td></tr>
<tr class="separator:a2e78165db877ece7dc8560d40104c010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf03d26dba3486c2ef847fe21e45186d"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#acf03d26dba3486c2ef847fe21e45186d">pool</a> () const noexcept</td></tr>
<tr class="separator:acf03d26dba3486c2ef847fe21e45186d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d620fcaff7dc7368e09ab90ad0988fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a4d620fcaff7dc7368e09ab90ad0988fe">release</a> () noexcept</td></tr>
<tr class="separator:a4d620fcaff7dc7368e09ab90ad0988fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22414d1fc1ac1c8c216d29bb97c2f63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#ac22414d1fc1ac1c8c216d29bb97c2f63">clear</a> () noexcept</td></tr>
<tr class="separator:ac22414d1fc1ac1c8c216d29bb97c2f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af814a61547813d3734c82c15db3708c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#af814a61547813d3734c82c15db3708c0">reserve</a> (std::size_t <a class="el" href="classseal_1_1_dyn_array.html#a2e78165db877ece7dc8560d40104c010">capacity</a>)</td></tr>
<tr class="separator:af814a61547813d3734c82c15db3708c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e454235ef642b569cfdc4d7d1dbcdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a45e454235ef642b569cfdc4d7d1dbcdb">shrink_to_fit</a> ()</td></tr>
<tr class="separator:a45e454235ef642b569cfdc4d7d1dbcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad1dd7b45966997ee4061ea58e5be2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a5ad1dd7b45966997ee4061ea58e5be2c">resize</a> (std::size_t <a class="el" href="classseal_1_1_dyn_array.html#ac458c4732f4f2ed188939f9ac5811fc5">size</a>, bool fill_zero=true)</td></tr>
<tr class="separator:a5ad1dd7b45966997ee4061ea58e5be2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126ee8b8c41b109e10b7c8d203a8ac23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a126ee8b8c41b109e10b7c8d203a8ac23">operator=</a> (const <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>&lt; T &gt; &amp;assign)</td></tr>
<tr class="separator:a126ee8b8c41b109e10b7c8d203a8ac23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b054f04c35fbe387e13dc59e0ecd6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#ac4b054f04c35fbe387e13dc59e0ecd6c">operator=</a> (<a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>&lt; T &gt; &amp;&amp;assign) noexcept</td></tr>
<tr class="separator:ac4b054f04c35fbe387e13dc59e0ecd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7ec385ee2d392d4f96afb13e3ef45b"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#afd7ec385ee2d392d4f96afb13e3ef45b">save_size</a> (compr_mode_type compr_mode=<a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a>) const</td></tr>
<tr class="separator:afd7ec385ee2d392d4f96afb13e3ef45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cf83105252e0c51946a382eececc29"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a93cf83105252e0c51946a382eececc29">save</a> (std::ostream &amp;stream, compr_mode_type compr_mode=<a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a>) const</td></tr>
<tr class="separator:a93cf83105252e0c51946a382eececc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9c386cf11410ddb8ca8820836b77e7"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#a6b9c386cf11410ddb8ca8820836b77e7">load</a> (std::istream &amp;stream, std::size_t in_size_bound=0)</td></tr>
<tr class="separator:a6b9c386cf11410ddb8ca8820836b77e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f66bb35239c47b7d281e5576ba12dc"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#af7f66bb35239c47b7d281e5576ba12dc">save</a> (seal_byte *out, std::size_t <a class="el" href="classseal_1_1_dyn_array.html#ac458c4732f4f2ed188939f9ac5811fc5">size</a>, compr_mode_type compr_mode=<a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a>) const</td></tr>
<tr class="separator:af7f66bb35239c47b7d281e5576ba12dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa72e6f9cf56a2349377484c0689e494"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_dyn_array.html#afa72e6f9cf56a2349377484c0689e494">load</a> (const seal_byte *in, std::size_t <a class="el" href="classseal_1_1_dyn_array.html#ac458c4732f4f2ed188939f9ac5811fc5">size</a>, std::size_t in_size_bound=0)</td></tr>
<tr class="separator:afa72e6f9cf56a2349377484c0689e494"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a460c3b2e4e402f22b7e74d53046c9803"><td class="memItemLeft" align="right" valign="top"><a id="a460c3b2e4e402f22b7e74d53046c9803" name="a460c3b2e4e402f22b7e74d53046c9803"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Ciphertext</b></td></tr>
<tr class="separator:a460c3b2e4e402f22b7e74d53046c9803"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class seal::DynArray&lt; T &gt;</div><p>A dynamic array for storing objects allocated from a Microsoft SEAL memory pool. The <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> class is mainly intended for internal use and provides the underlying data structure for <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> and <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> classes.</p>
<dl class="section user"><dt>Size and Capacity</dt><dd><a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> allows the user to pre-allocate memory (capacity) for the array in cases where the array is known to be resized in the future and memory moves are to be avoided at the time of resizing. The size of the <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> can never exceed its capacity. The capacity and size can be changed using the reserve and resize functions, respectively.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>In general, reading from <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> is thread-safe as long as no other thread is concurrently mutating it. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a96556491782dd58d70c52b8ac1a50349" name="a96556491782dd58d70c52b8ac1a50349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96556491782dd58d70c52b8ac1a50349">&#9670;&#160;</a></span>DynArray() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::DynArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>. No memory is allocated by this constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a790e24c14510af175423542a804be54f" name="a790e24c14510af175423542a804be54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790e24c14510af175423542a804be54f">&#9670;&#160;</a></span>DynArray() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::DynArray </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> with given size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8184176f2dabccdc2d58dffde65489b" name="ab8184176f2dabccdc2d58dffde65489b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8184176f2dabccdc2d58dffde65489b">&#9670;&#160;</a></span>DynArray() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::DynArray </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> with given capacity and size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>The capacity of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if capacity is less than size </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6986a196edb3e1da2398483da229ad1b" name="a6986a196edb3e1da2398483da229ad1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6986a196edb3e1da2398483da229ad1b">&#9670;&#160;</a></span>DynArray() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::DynArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1util_1_1_pointer.html">util::Pointer</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fill_zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> with given size wrapping a given pointer. This constructor allocates no memory. If the <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> goes out of scope, the Pointer object given here is destroyed. On resizing the <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> to larger size, the data will be copied over to a new allocation from the memory pool pointer to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> and the Pointer object given here will subsequently be destroyed. Unlike the other constructors, this one exposes the option of not automatically zero-filling the allocated memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>An initial Pointer object to wrap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>The capacity of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fill_zero</td><td>If true, fills ptr with zeros </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if ptr is null and capacity is positive </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if capacity is less than size </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bd10b07a35df13a3f3da9a32434fabf" name="a5bd10b07a35df13a3f3da9a32434fabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd10b07a35df13a3f3da9a32434fabf">&#9670;&#160;</a></span>DynArray() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::DynArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1util_1_1_pointer.html">util::Pointer</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fill_zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> with given size wrapping a given pointer. This constructor allocates no memory. If the <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> goes out of scope, the Pointer object given here is destroyed. On resizing the <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> to larger size, the data will be copied over to a new allocation from the memory pool pointer to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> and the Pointer object given here will subsequently be destroyed. Unlike the other constructors, this one exposes the option of not automatically zero-filling the allocated memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>An initial Pointer object to wrap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fill_zero</td><td>If true, fills ptr with zeros </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if ptr is null and size is positive </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae31f7f63760a708c8c21da9cdf4ae610" name="ae31f7f63760a708c8c21da9cdf4ae610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31f7f63760a708c8c21da9cdf4ae610">&#9670;&#160;</a></span>DynArray() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::DynArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> by copying a given one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copy</td><td>The <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6484fb984bd4d244bf4cb36c5a7aaa0" name="af6484fb984bd4d244bf4cb36c5a7aaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6484fb984bd4d244bf4cb36c5a7aaa0">&#9670;&#160;</a></span>DynArray() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::DynArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> by moving a given one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8871bb4d14ad06653d483355c0acaa0" name="af8871bb4d14ad06653d483355c0acaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8871bb4d14ad06653d483355c0acaa0">&#9670;&#160;</a></span>~DynArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::~<a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys the <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4c9b85469b05a97fac16ef64c62ba9c3" name="a4c9b85469b05a97fac16ef64c62ba9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9b85469b05a97fac16ef64c62ba9c3">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD T &amp; <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the array element at a given index. This function performs bounds checking and will throw an error if the index is out of range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the array element </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is out of range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10a6d5c16f475d2f2d620dc27f04162a" name="a10a6d5c16f475d2f2d620dc27f04162a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a6d5c16f475d2f2d620dc27f04162a">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const T &amp; <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant reference to the array element at a given index. This function performs bounds checking and will throw an error if the index is out of range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the array element </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is out of range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fcf3ed42d037dd152f1bf0728530d3e" name="a2fcf3ed42d037dd152f1bf0728530d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fcf3ed42d037dd152f1bf0728530d3e">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const T * <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant pointer to the beginning of the array data. </p>

</div>
</div>
<a id="aae36122e91c1b98e587ee267cdbe4247" name="aae36122e91c1b98e587ee267cdbe4247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae36122e91c1b98e587ee267cdbe4247">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD T * <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the beginning of the array data. </p>

</div>
</div>
<a id="a2e78165db877ece7dc8560d40104c010" name="a2e78165db877ece7dc8560d40104c010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e78165db877ece7dc8560d40104c010">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::size_t <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the capacity of the array. </p>

</div>
</div>
<a id="a6614fb84d8a226863b9f72ab39afd552" name="a6614fb84d8a226863b9f72ab39afd552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6614fb84d8a226863b9f72ab39afd552">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const T * <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant pointer to the beginning of the array data. </p>

</div>
</div>
<a id="a78708e046c2d3a3f6dc3593b2b85a024" name="a78708e046c2d3a3f6dc3593b2b85a024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78708e046c2d3a3f6dc3593b2b85a024">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const T * <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant pointer to the end of the array data. </p>

</div>
</div>
<a id="ac22414d1fc1ac1c8c216d29bb97c2f63" name="ac22414d1fc1ac1c8c216d29bb97c2f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22414d1fc1ac1c8c216d29bb97c2f63">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the size of the array to zero. The capacity is not changed. </p>

</div>
</div>
<a id="ad8ab55f17cd7c081f7fde46f2567d2d2" name="ad8ab55f17cd7c081f7fde46f2567d2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ab55f17cd7c081f7fde46f2567d2d2">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the array has size zero. </p>

</div>
</div>
<a id="a7bd88e79be1623df2f792299ba8a08b7" name="a7bd88e79be1623df2f792299ba8a08b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd88e79be1623df2f792299ba8a08b7">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const T * <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant pointer to the end of the array data. </p>

</div>
</div>
<a id="afe7a4c43eec9ea5121dd095b9171fea4" name="afe7a4c43eec9ea5121dd095b9171fea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7a4c43eec9ea5121dd095b9171fea4">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD T * <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the end of the array data. </p>

</div>
</div>
<a id="afa72e6f9cf56a2349377484c0689e494" name="afa72e6f9cf56a2349377484c0689e494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa72e6f9cf56a2349377484c0689e494">&#9670;&#160;</a></span>load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::load </td>
          <td>(</td>
          <td class="paramtype">const seal_byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>in_size_bound</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads a <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> from a given memory location overwriting the current <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>. This function takes optionally a bound on the size for the loaded <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> and throws an exception if the size indicated by the loaded metadata exceeds the provided value. The check is omitted if in_size_bound is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>The memory location to load the <a class="el" href="classseal_1_1_modulus.html">Modulus</a> from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes available in the given memory location </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_size_bound</td><td>A bound on the size of the loaded <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if in is null or if size is too small to contain a SEALHeader </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the data cannot be loaded by this version of Microsoft SEAL, if the loaded data is invalid, if decompression failed, or if the loaded size exceeds in_size_bound </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if I/O operations failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b9c386cf11410ddb8ca8820836b77e7" name="a6b9c386cf11410ddb8ca8820836b77e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9c386cf11410ddb8ca8820836b77e7">&#9670;&#160;</a></span>load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::load </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>in_size_bound</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads a <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> from an input stream overwriting the current <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>. This function takes optionally a bound on the size for the loaded <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> and throws an exception if the size indicated by the loaded metadata exceeds the provided value. The check is omitted if in_size_bound is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream to load the <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_size_bound</td><td>A bound on the size of the loaded <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the data cannot be loaded by this version of Microsoft SEAL, if the loaded data is invalid, if decompression failed, or if the loaded size exceeds in_size_bound </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the loaded data is invalid, if the loaded size exceeds in_size_bound, or if decompression failed </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if I/O operations failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a749961e05095219111badffa70cd86f2" name="a749961e05095219111badffa70cd86f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749961e05095219111badffa70cd86f2">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::size_t <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the largest possible array size. </p>

</div>
</div>
<a id="a126ee8b8c41b109e10b7c8d203a8ac23" name="a126ee8b8c41b109e10b7c8d203a8ac23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126ee8b8c41b109e10b7c8d203a8ac23">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>&lt; T &gt; &amp; <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>assign</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies a given <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> to the current one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">assign</td><td>The <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4b054f04c35fbe387e13dc59e0ecd6c" name="ac4b054f04c35fbe387e13dc59e0ecd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b054f04c35fbe387e13dc59e0ecd6c">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>&lt; T &gt; &amp; <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>assign</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Moves a given <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> to the current one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">assign</td><td>The <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9e667d02a8b7a15c3b73003ffb90074" name="ac9e667d02a8b7a15c3b73003ffb90074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e667d02a8b7a15c3b73003ffb90074">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD T &amp; <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the array element at a given index. This function does not perform bounds checking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the array element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c81dd214d1c6c00a30e4d51c78ce9d9" name="a4c81dd214d1c6c00a30e4d51c78ce9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c81dd214d1c6c00a30e4d51c78ce9d9">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const T &amp; <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant reference to the array element at a given index. This function does not perform bounds checking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the array element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf03d26dba3486c2ef847fe21e45186d" name="acf03d26dba3486c2ef847fe21e45186d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf03d26dba3486c2ef847fe21e45186d">&#9670;&#160;</a></span>pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the currently used <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>. </p>

</div>
</div>
<a id="a4d620fcaff7dc7368e09ab90ad0988fe" name="a4d620fcaff7dc7368e09ab90ad0988fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d620fcaff7dc7368e09ab90ad0988fe">&#9670;&#160;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Releases any allocated memory to the memory pool and sets the size and capacity of the array to zero. </p>

</div>
</div>
<a id="af814a61547813d3734c82c15db3708c0" name="af814a61547813d3734c82c15db3708c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af814a61547813d3734c82c15db3708c0">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates enough memory for storing a given number of elements without changing the size of the array. If the given capacity is smaller than the current size, the size is automatically set to equal the new capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>The capacity of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ad1dd7b45966997ee4061ea58e5be2c" name="a5ad1dd7b45966997ee4061ea58e5be2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad1dd7b45966997ee4061ea58e5be2c">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fill_zero</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the array to given size. When resizing to larger size the data in the array remains unchanged and any new space is initialized to zero if fill_zero is set to true; when resizing to smaller size the last elements of the array are dropped. If the capacity is not already large enough to hold the new size, the array is also reallocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fill_zero</td><td>If true, fills expanded space with zeros </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7f66bb35239c47b7d281e5576ba12dc" name="af7f66bb35239c47b7d281e5576ba12dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f66bb35239c47b7d281e5576ba12dc">&#9670;&#160;</a></span>save() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::save </td>
          <td>(</td>
          <td class="paramtype">seal_byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compr_mode_type&#160;</td>
          <td class="paramname"><em>compr_mode</em> = <code><a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves the <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> to a given memory location. The output is in binary format and not human-readable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>The memory location to write the <a class="el" href="classseal_1_1_modulus.html">Modulus</a> to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes available in the given memory location </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compr_mode</td><td>The desired compression mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if out is null or if size is too small to contain a SEALHeader, or if the compression mode is not supported </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the data to be saved is invalid, or if compression failed </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if I/O operations failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93cf83105252e0c51946a382eececc29" name="a93cf83105252e0c51946a382eececc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93cf83105252e0c51946a382eececc29">&#9670;&#160;</a></span>save() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::save </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compr_mode_type&#160;</td>
          <td class="paramname"><em>compr_mode</em> = <code><a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves the <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> to an output stream. The output is in binary format and not human-readable. The output stream must have the "binary" flag set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stream</td><td>The stream to save the <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compr_mode</td><td>The desired compression mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the compression mode is not supported </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the data to be saved is invalid, or if compression failed </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if I/O operations failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd7ec385ee2d392d4f96afb13e3ef45b" name="afd7ec385ee2d392d4f96afb13e3ef45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7ec385ee2d392d4f96afb13e3ef45b">&#9670;&#160;</a></span>save_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::streamoff <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::save_size </td>
          <td>(</td>
          <td class="paramtype">compr_mode_type&#160;</td>
          <td class="paramname"><em>compr_mode</em> = <code><a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an upper bound on the size of the <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a>, as if it was written to an output stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compr_mode</td><td>The compression mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the compression mode is not supported </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the size does not fit in the return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45e454235ef642b569cfdc4d7d1dbcdb" name="a45e454235ef642b569cfdc4d7d1dbcdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e454235ef642b569cfdc4d7d1dbcdb">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reallocates the array so that its capacity exactly matches its size. </p>

</div>
</div>
<a id="ac458c4732f4f2ed188939f9ac5811fc5" name="ac458c4732f4f2ed188939f9ac5811fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac458c4732f4f2ed188939f9ac5811fc5">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::size_t <a class="el" href="classseal_1_1_dyn_array.html">seal::DynArray</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size of the array. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>seal/<a class="el" href="dynarray_8h_source.html">dynarray.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
