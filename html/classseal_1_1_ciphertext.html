<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEAL: seal::Ciphertext Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SEAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>seal</b></li><li class="navelem"><a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseal_1_1_ciphertext-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">seal::Ciphertext Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ciphertext_8h_source.html">ciphertext.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3c514906419ee5c53c99ea1abf240ee1"><td class="memItemLeft" align="right" valign="top"><a id="a3c514906419ee5c53c99ea1abf240ee1" name="a3c514906419ee5c53c99ea1abf240ee1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ct_coeff_type</b> = std::uint64_t</td></tr>
<tr class="separator:a3c514906419ee5c53c99ea1abf240ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0cac613421bbcd9e9eff9ce83ae65a1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a0cac613421bbcd9e9eff9ce83ae65a1e">Ciphertext</a> (<a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1_ciphertext.html#a151a5b5d88fb0be12d6542efecdd8cac">pool</a>=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a0cac613421bbcd9e9eff9ce83ae65a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66e152357f1b4d4ff3400ee51a109c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#aa66e152357f1b4d4ff3400ee51a109c2">Ciphertext</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1_ciphertext.html#a151a5b5d88fb0be12d6542efecdd8cac">pool</a>=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:aa66e152357f1b4d4ff3400ee51a109c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05088a02df3d41bb7004467aff3835e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#ad05088a02df3d41bb7004467aff3835e">Ciphertext</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, parms_id_type <a class="el" href="classseal_1_1_ciphertext.html#a988a73d6c998663fa888cb5af0c30184">parms_id</a>, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1_ciphertext.html#a151a5b5d88fb0be12d6542efecdd8cac">pool</a>=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:ad05088a02df3d41bb7004467aff3835e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20828224d227c77601e220ad8d79db89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a20828224d227c77601e220ad8d79db89">Ciphertext</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, parms_id_type <a class="el" href="classseal_1_1_ciphertext.html#a988a73d6c998663fa888cb5af0c30184">parms_id</a>, std::size_t <a class="el" href="classseal_1_1_ciphertext.html#a6ed9c8dd55f83d0494d9b57dd2f0a7b8">size_capacity</a>, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1_ciphertext.html#a151a5b5d88fb0be12d6542efecdd8cac">pool</a>=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>())</td></tr>
<tr class="separator:a20828224d227c77601e220ad8d79db89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358a2250862e978e31dfe10b981f673d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a358a2250862e978e31dfe10b981f673d">Ciphertext</a> (const <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;copy)=default</td></tr>
<tr class="separator:a358a2250862e978e31dfe10b981f673d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23117f3ab5c2fff84b59335677fc2b12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a23117f3ab5c2fff84b59335677fc2b12">Ciphertext</a> (<a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;&amp;source)=default</td></tr>
<tr class="separator:a23117f3ab5c2fff84b59335677fc2b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0d93274bb109b1b3e7f63079d38009"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a4a0d93274bb109b1b3e7f63079d38009">Ciphertext</a> (const <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;copy, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> <a class="el" href="classseal_1_1_ciphertext.html#a151a5b5d88fb0be12d6542efecdd8cac">pool</a>)</td></tr>
<tr class="separator:a4a0d93274bb109b1b3e7f63079d38009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b5dab550e491ebab245bb776ebbbf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#ae9b5dab550e491ebab245bb776ebbbf3">reserve</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, parms_id_type <a class="el" href="classseal_1_1_ciphertext.html#a988a73d6c998663fa888cb5af0c30184">parms_id</a>, std::size_t <a class="el" href="classseal_1_1_ciphertext.html#a6ed9c8dd55f83d0494d9b57dd2f0a7b8">size_capacity</a>)</td></tr>
<tr class="separator:ae9b5dab550e491ebab245bb776ebbbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4d03f9e85e060641c9799c1cec3a72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a9c4d03f9e85e060641c9799c1cec3a72">reserve</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, std::size_t <a class="el" href="classseal_1_1_ciphertext.html#a6ed9c8dd55f83d0494d9b57dd2f0a7b8">size_capacity</a>)</td></tr>
<tr class="separator:a9c4d03f9e85e060641c9799c1cec3a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1891148112ea9dccd8cf621fd4212bde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a1891148112ea9dccd8cf621fd4212bde">reserve</a> (std::size_t <a class="el" href="classseal_1_1_ciphertext.html#a6ed9c8dd55f83d0494d9b57dd2f0a7b8">size_capacity</a>)</td></tr>
<tr class="separator:a1891148112ea9dccd8cf621fd4212bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b25806bea9a3d7d3a180e8a0f98848e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a2b25806bea9a3d7d3a180e8a0f98848e">resize</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, parms_id_type <a class="el" href="classseal_1_1_ciphertext.html#a988a73d6c998663fa888cb5af0c30184">parms_id</a>, std::size_t <a class="el" href="classseal_1_1_ciphertext.html#a7ccc1a32a309ce4a72bf6622f79b2096">size</a>)</td></tr>
<tr class="separator:a2b25806bea9a3d7d3a180e8a0f98848e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d815ba720159b1c2cbcee98a5ff3b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a69d815ba720159b1c2cbcee98a5ff3b6">resize</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, std::size_t <a class="el" href="classseal_1_1_ciphertext.html#a7ccc1a32a309ce4a72bf6622f79b2096">size</a>)</td></tr>
<tr class="separator:a69d815ba720159b1c2cbcee98a5ff3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd34137f1afab52cc33192b1e730278"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a2fd34137f1afab52cc33192b1e730278">resize</a> (std::size_t <a class="el" href="classseal_1_1_ciphertext.html#a7ccc1a32a309ce4a72bf6622f79b2096">size</a>)</td></tr>
<tr class="separator:a2fd34137f1afab52cc33192b1e730278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb26786de6ee2f17e162bfaf3f90a9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a3eb26786de6ee2f17e162bfaf3f90a9f">release</a> () noexcept</td></tr>
<tr class="separator:a3eb26786de6ee2f17e162bfaf3f90a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad215911c2bbb6ada8f653cd97530e8d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#ad215911c2bbb6ada8f653cd97530e8d8">operator=</a> (const <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;assign)</td></tr>
<tr class="separator:ad215911c2bbb6ada8f653cd97530e8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fb58c3d8f4e7e57f513c8cff659438"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a99fb58c3d8f4e7e57f513c8cff659438">operator=</a> (<a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;&amp;assign)=default</td></tr>
<tr class="separator:a99fb58c3d8f4e7e57f513c8cff659438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfef8b5dcf746a6cb50ef8b20134f1e"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a3cfef8b5dcf746a6cb50ef8b20134f1e">dyn_array</a> () const noexcept</td></tr>
<tr class="separator:a3cfef8b5dcf746a6cb50ef8b20134f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cb76b60cd6b7ecfce8372175bb1a3e"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD ct_coeff_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a70cb76b60cd6b7ecfce8372175bb1a3e">data</a> () noexcept</td></tr>
<tr class="separator:a70cb76b60cd6b7ecfce8372175bb1a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547f104e661d1a976fda9cabb71902d8"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const ct_coeff_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a547f104e661d1a976fda9cabb71902d8">data</a> () const noexcept</td></tr>
<tr class="separator:a547f104e661d1a976fda9cabb71902d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b6baf72409e79ab85dd9cadf56ea0d"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD ct_coeff_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a76b6baf72409e79ab85dd9cadf56ea0d">data</a> (std::size_t poly_index)</td></tr>
<tr class="separator:a76b6baf72409e79ab85dd9cadf56ea0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9ad41e383afd0effa5d4f9d58517b9"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const ct_coeff_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a0b9ad41e383afd0effa5d4f9d58517b9">data</a> (std::size_t poly_index) const</td></tr>
<tr class="separator:a0b9ad41e383afd0effa5d4f9d58517b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f94ad2d14b9bf443e4674dec51cbf6"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD ct_coeff_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a63f94ad2d14b9bf443e4674dec51cbf6">operator[]</a> (std::size_t coeff_index)</td></tr>
<tr class="separator:a63f94ad2d14b9bf443e4674dec51cbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8561ff0a06ba943001a779606ffbfdad"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const ct_coeff_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a8561ff0a06ba943001a779606ffbfdad">operator[]</a> (std::size_t coeff_index) const</td></tr>
<tr class="separator:a8561ff0a06ba943001a779606ffbfdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2520a06a5825970f85ac6047f5f0d7"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#afe2520a06a5825970f85ac6047f5f0d7">coeff_modulus_size</a> () const noexcept</td></tr>
<tr class="separator:afe2520a06a5825970f85ac6047f5f0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f5952371e98c9831ebe825a566234a"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#aa1f5952371e98c9831ebe825a566234a">poly_modulus_degree</a> () const noexcept</td></tr>
<tr class="separator:aa1f5952371e98c9831ebe825a566234a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccc1a32a309ce4a72bf6622f79b2096"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a7ccc1a32a309ce4a72bf6622f79b2096">size</a> () const noexcept</td></tr>
<tr class="separator:a7ccc1a32a309ce4a72bf6622f79b2096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed9c8dd55f83d0494d9b57dd2f0a7b8"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a6ed9c8dd55f83d0494d9b57dd2f0a7b8">size_capacity</a> () const noexcept</td></tr>
<tr class="separator:a6ed9c8dd55f83d0494d9b57dd2f0a7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5598b874402f91cd5108fecd488b16e8"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a5598b874402f91cd5108fecd488b16e8">is_transparent</a> () const</td></tr>
<tr class="separator:a5598b874402f91cd5108fecd488b16e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82469a60fb4805d9f28358c3b5e980d2"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a82469a60fb4805d9f28358c3b5e980d2">save_size</a> (compr_mode_type compr_mode=<a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a>) const</td></tr>
<tr class="separator:a82469a60fb4805d9f28358c3b5e980d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc1c076290039e6de34764d7f722bba"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#aebc1c076290039e6de34764d7f722bba">save</a> (std::ostream &amp;stream, compr_mode_type compr_mode=<a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a>) const</td></tr>
<tr class="separator:aebc1c076290039e6de34764d7f722bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584429fcc0b3a2e6b80a8d94476ac03d"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a584429fcc0b3a2e6b80a8d94476ac03d">unsafe_load</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, std::istream &amp;stream)</td></tr>
<tr class="separator:a584429fcc0b3a2e6b80a8d94476ac03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a59d80fd7aa3fefc65dd0881e14b9e"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a94a59d80fd7aa3fefc65dd0881e14b9e">load</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, std::istream &amp;stream)</td></tr>
<tr class="separator:a94a59d80fd7aa3fefc65dd0881e14b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3a0d65ddace1a349dc316503559466"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a4f3a0d65ddace1a349dc316503559466">save</a> (seal_byte *out, std::size_t <a class="el" href="classseal_1_1_ciphertext.html#a7ccc1a32a309ce4a72bf6622f79b2096">size</a>, compr_mode_type compr_mode=<a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a>) const</td></tr>
<tr class="separator:a4f3a0d65ddace1a349dc316503559466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e36764d9c6795693ad7de92f9856ec"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#ac3e36764d9c6795693ad7de92f9856ec">unsafe_load</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, const seal_byte *in, std::size_t <a class="el" href="classseal_1_1_ciphertext.html#a7ccc1a32a309ce4a72bf6622f79b2096">size</a>)</td></tr>
<tr class="separator:ac3e36764d9c6795693ad7de92f9856ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02799d303ea6018a1a6c0454d1f19d58"><td class="memItemLeft" align="right" valign="top">std::streamoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a02799d303ea6018a1a6c0454d1f19d58">load</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context, const seal_byte *in, std::size_t <a class="el" href="classseal_1_1_ciphertext.html#a7ccc1a32a309ce4a72bf6622f79b2096">size</a>)</td></tr>
<tr class="separator:a02799d303ea6018a1a6c0454d1f19d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f13c16aafb53edfdd75e1597c0b6b1"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a68f13c16aafb53edfdd75e1597c0b6b1">is_ntt_form</a> () const noexcept</td></tr>
<tr class="separator:a68f13c16aafb53edfdd75e1597c0b6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ee14ec9c3064dbab318580f484d544"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#ae5ee14ec9c3064dbab318580f484d544">is_ntt_form</a> () noexcept</td></tr>
<tr class="separator:ae5ee14ec9c3064dbab318580f484d544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988a73d6c998663fa888cb5af0c30184"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD parms_id_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a988a73d6c998663fa888cb5af0c30184">parms_id</a> () noexcept</td></tr>
<tr class="separator:a988a73d6c998663fa888cb5af0c30184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6775672dc96aefb426e555a642609645"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const parms_id_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a6775672dc96aefb426e555a642609645">parms_id</a> () const noexcept</td></tr>
<tr class="separator:a6775672dc96aefb426e555a642609645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bc454e13298b1416d238f5ec85fc1c"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a07bc454e13298b1416d238f5ec85fc1c">scale</a> () noexcept</td></tr>
<tr class="separator:a07bc454e13298b1416d238f5ec85fc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080d2e856faa5b617bda9e280824192d"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a080d2e856faa5b617bda9e280824192d">scale</a> () const noexcept</td></tr>
<tr class="separator:a080d2e856faa5b617bda9e280824192d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc19ae782e390113c269798a13e2ff9d"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::uint64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#acc19ae782e390113c269798a13e2ff9d">correction_factor</a> () noexcept</td></tr>
<tr class="separator:acc19ae782e390113c269798a13e2ff9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cf7c4797c7b70e4d365dd02f273462"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD const std::uint64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#ab9cf7c4797c7b70e4d365dd02f273462">correction_factor</a> () const noexcept</td></tr>
<tr class="separator:ab9cf7c4797c7b70e4d365dd02f273462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151a5b5d88fb0be12d6542efecdd8cac"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_ciphertext.html#a151a5b5d88fb0be12d6542efecdd8cac">pool</a> () const noexcept</td></tr>
<tr class="separator:a151a5b5d88fb0be12d6542efecdd8cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to store a ciphertext element. The data for a ciphertext consists of two or more polynomials, which are in Microsoft SEAL stored in a CRT form with respect to the factors of the coefficient modulus. This data itself is not meant to be modified directly by the user, but is instead operated on by functions in the <a class="el" href="classseal_1_1_evaluator.html">Evaluator</a> class. The size of the backing array of a ciphertext depends on the encryption parameters and the size of the ciphertext (at least 2). If the size of the ciphertext is T, the poly_modulus_degree encryption parameter is N, and the number of primes in the coeff_modulus encryption parameter is K, then the ciphertext backing array requires precisely 8*N*K*T bytes of memory. A ciphertext also carries with it the parms_id of its associated encryption parameters, which is used to check the validity of the ciphertext for homomorphic operations and decryption.</p>
<dl class="section user"><dt>Memory Management</dt><dd>The size of a ciphertext refers to the number of polynomials it contains, whereas its capacity refers to the number of polynomials that fit in the current memory allocation. In high-performance applications unnecessary re-allocations should be avoided by reserving enough memory for the ciphertext to begin with either by providing the desired capacity to the constructor as an extra argument, or by calling the reserve function at any time.</dd></dl>
<dl class="section user"><dt>Thread Safety</dt><dd>In general, reading from ciphertext is thread-safe as long as no other thread is concurrently mutating it. This is due to the underlying data structure storing the ciphertext not being thread-safe.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> for the class that stores plaintexts. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0cac613421bbcd9e9eff9ce83ae65a1e" name="a0cac613421bbcd9e9eff9ce83ae65a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cac613421bbcd9e9eff9ce83ae65a1e">&#9670;&#160;</a></span>Ciphertext() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::Ciphertext::Ciphertext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an empty ciphertext allocating no memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa66e152357f1b4d4ff3400ee51a109c2" name="aa66e152357f1b4d4ff3400ee51a109c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66e152357f1b4d4ff3400ee51a109c2">&#9670;&#160;</a></span>Ciphertext() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::Ciphertext::Ciphertext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an empty ciphertext with capacity 2. In addition to the capacity, the allocation size is determined by the highest-level parameters associated to the given <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad05088a02df3d41bb7004467aff3835e" name="ad05088a02df3d41bb7004467aff3835e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05088a02df3d41bb7004467aff3835e">&#9670;&#160;</a></span>Ciphertext() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::Ciphertext::Ciphertext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an empty ciphertext with capacity 2. In addition to the capacity, the allocation size is determined by the encryption parameters with given parms_id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>The parms_id corresponding to the encryption parameters to be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20828224d227c77601e220ad8d79db89" name="a20828224d227c77601e220ad8d79db89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20828224d227c77601e220ad8d79db89">&#9670;&#160;</a></span>Ciphertext() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::Ciphertext::Ciphertext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an empty ciphertext with given capacity. In addition to the capacity, the allocation size is determined by the given encryption parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>The parms_id corresponding to the encryption parameters to be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_capacity</td><td>The capacity </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if size_capacity is less than 2 or too large </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a358a2250862e978e31dfe10b981f673d" name="a358a2250862e978e31dfe10b981f673d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358a2250862e978e31dfe10b981f673d">&#9670;&#160;</a></span>Ciphertext() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::Ciphertext::Ciphertext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new ciphertext by copying a given one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copy</td><td>The ciphertext to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23117f3ab5c2fff84b59335677fc2b12" name="a23117f3ab5c2fff84b59335677fc2b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23117f3ab5c2fff84b59335677fc2b12">&#9670;&#160;</a></span>Ciphertext() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::Ciphertext::Ciphertext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new ciphertext by moving a given one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The ciphertext to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a0d93274bb109b1b3e7f63079d38009" name="a4a0d93274bb109b1b3e7f63079d38009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0d93274bb109b1b3e7f63079d38009">&#9670;&#160;</a></span>Ciphertext() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">seal::Ciphertext::Ciphertext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new ciphertext by copying a given one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">copy</td><td>The ciphertext to copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afe2520a06a5825970f85ac6047f5f0d7" name="afe2520a06a5825970f85ac6047f5f0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2520a06a5825970f85ac6047f5f0d7">&#9670;&#160;</a></span>coeff_modulus_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::size_t seal::Ciphertext::coeff_modulus_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of primes in the coefficient modulus of the associated encryption parameters. This directly affects the allocation size of the ciphertext. </p>

</div>
</div>
<a id="ab9cf7c4797c7b70e4d365dd02f273462" name="ab9cf7c4797c7b70e4d365dd02f273462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cf7c4797c7b70e4d365dd02f273462">&#9670;&#160;</a></span>correction_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const std::uint64_t &amp; seal::Ciphertext::correction_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant reference to the correction factor. This is only needed when using the BGV encryption scheme. </p>

</div>
</div>
<a id="acc19ae782e390113c269798a13e2ff9d" name="acc19ae782e390113c269798a13e2ff9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc19ae782e390113c269798a13e2ff9d">&#9670;&#160;</a></span>correction_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::uint64_t &amp; seal::Ciphertext::correction_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the correction factor. This is only needed when using the BGV encryption scheme. The user should have little or no reason to ever change the correction factor by hand. </p>

</div>
</div>
<a id="a547f104e661d1a976fda9cabb71902d8" name="a547f104e661d1a976fda9cabb71902d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547f104e661d1a976fda9cabb71902d8">&#9670;&#160;</a></span>data() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const ct_coeff_type * seal::Ciphertext::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const pointer to the beginning of the ciphertext data. </p>

</div>
</div>
<a id="a70cb76b60cd6b7ecfce8372175bb1a3e" name="a70cb76b60cd6b7ecfce8372175bb1a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cb76b60cd6b7ecfce8372175bb1a3e">&#9670;&#160;</a></span>data() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD ct_coeff_type * seal::Ciphertext::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the beginning of the ciphertext data. </p>

</div>
</div>
<a id="a76b6baf72409e79ab85dd9cadf56ea0d" name="a76b6baf72409e79ab85dd9cadf56ea0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b6baf72409e79ab85dd9cadf56ea0d">&#9670;&#160;</a></span>data() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD ct_coeff_type * seal::Ciphertext::data </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>poly_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to a particular polynomial in the ciphertext data. Note that Microsoft SEAL stores each polynomial in the ciphertext modulo all of the K primes in the coefficient modulus. The pointer returned by this function is to the beginning (constant coefficient) of the first one of these K polynomials.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly_index</td><td>The index of the polynomial in the ciphertext </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if poly_index is less than 0 or bigger than the size of the ciphertext </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b9ad41e383afd0effa5d4f9d58517b9" name="a0b9ad41e383afd0effa5d4f9d58517b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9ad41e383afd0effa5d4f9d58517b9">&#9670;&#160;</a></span>data() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const ct_coeff_type * seal::Ciphertext::data </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>poly_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const pointer to a particular polynomial in the ciphertext data. Note that Microsoft SEAL stores each polynomial in the ciphertext modulo all of the K primes in the coefficient modulus. The pointer returned by this function is to the beginning (constant coefficient) of the first one of these K polynomials.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly_index</td><td>The index of the polynomial in the ciphertext </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if poly_index is out of range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cfef8b5dcf746a6cb50ef8b20134f1e" name="a3cfef8b5dcf746a6cb50ef8b20134f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfef8b5dcf746a6cb50ef8b20134f1e">&#9670;&#160;</a></span>dyn_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const auto &amp; seal::Ciphertext::dyn_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the backing <a class="el" href="classseal_1_1_dyn_array.html">DynArray</a> object. </p>

</div>
</div>
<a id="a68f13c16aafb53edfdd75e1597c0b6b1" name="a68f13c16aafb53edfdd75e1597c0b6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f13c16aafb53edfdd75e1597c0b6b1">&#9670;&#160;</a></span>is_ntt_form() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::Ciphertext::is_ntt_form </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the ciphertext is in NTT form. </p>

</div>
</div>
<a id="ae5ee14ec9c3064dbab318580f484d544" name="ae5ee14ec9c3064dbab318580f484d544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ee14ec9c3064dbab318580f484d544">&#9670;&#160;</a></span>is_ntt_form() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool &amp; seal::Ciphertext::is_ntt_form </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the ciphertext is in NTT form. </p>

</div>
</div>
<a id="a5598b874402f91cd5108fecd488b16e8" name="a5598b874402f91cd5108fecd488b16e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5598b874402f91cd5108fecd488b16e8">&#9670;&#160;</a></span>is_transparent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD bool seal::Ciphertext::is_transparent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check whether the current ciphertext is transparent, i.e. does not require a secret key to decrypt. In typical security models such transparent ciphertexts would not be considered to be valid. Starting from the second polynomial in the current ciphertext, this function returns true if all following coefficients are identically zero. Otherwise, returns false. </p>

</div>
</div>
<a id="a02799d303ea6018a1a6c0454d1f19d58" name="a02799d303ea6018a1a6c0454d1f19d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02799d303ea6018a1a6c0454d1f19d58">&#9670;&#160;</a></span>load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff seal::Ciphertext::load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const seal_byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads a ciphertext from a given memory location overwriting the current ciphertext. The loaded ciphertext is verified to be valid for the given <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>The memory location to load the ciphertext from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes available in the given memory location </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if in is null or if size is too small to contain a SEALHeader </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the data cannot be loaded by this version of Microsoft SEAL, if the loaded data is invalid, or if decompression failed </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if I/O operations failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94a59d80fd7aa3fefc65dd0881e14b9e" name="a94a59d80fd7aa3fefc65dd0881e14b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a59d80fd7aa3fefc65dd0881e14b9e">&#9670;&#160;</a></span>load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff seal::Ciphertext::load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads a ciphertext from an input stream overwriting the current ciphertext. The loaded ciphertext is verified to be valid for the given <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream to load the ciphertext from </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the data cannot be loaded by this version of Microsoft SEAL, if the loaded data is invalid, or if decompression failed </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if I/O operations failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99fb58c3d8f4e7e57f513c8cff659438" name="a99fb58c3d8f4e7e57f513c8cff659438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fb58c3d8f4e7e57f513c8cff659438">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp; seal::Ciphertext::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>assign</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Moves a given ciphertext to the current one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">assign</td><td>The ciphertext to move from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad215911c2bbb6ada8f653cd97530e8d8" name="ad215911c2bbb6ada8f653cd97530e8d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad215911c2bbb6ada8f653cd97530e8d8">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp; seal::Ciphertext::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> &amp;&#160;</td>
          <td class="paramname"><em>assign</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a given ciphertext to the current one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">assign</td><td>The ciphertext to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63f94ad2d14b9bf443e4674dec51cbf6" name="a63f94ad2d14b9bf443e4674dec51cbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f94ad2d14b9bf443e4674dec51cbf6">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD ct_coeff_type &amp; seal::Ciphertext::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>coeff_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to a polynomial coefficient at a particular index in the ciphertext data. If the polynomial modulus has degree N, and the number of primes in the coefficient modulus is K, then the ciphertext contains size*N*K coefficients. Thus, the coeff_index has a range of [0, size*N*K).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coeff_index</td><td>The index of the coefficient </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if coeff_index is out of range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8561ff0a06ba943001a779606ffbfdad" name="a8561ff0a06ba943001a779606ffbfdad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8561ff0a06ba943001a779606ffbfdad">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const ct_coeff_type &amp; seal::Ciphertext::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>coeff_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const reference to a polynomial coefficient at a particular index in the ciphertext data. If the polynomial modulus has degree N, and the number of primes in the coefficient modulus is K, then the ciphertext contains size*N*K coefficients. Thus, the coeff_index has a range of [0, size*N*K).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coeff_index</td><td>The index of the coefficient </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if coeff_index is out of range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6775672dc96aefb426e555a642609645" name="a6775672dc96aefb426e555a642609645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6775672dc96aefb426e555a642609645">&#9670;&#160;</a></span>parms_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const parms_id_type &amp; seal::Ciphertext::parms_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const reference to parms_id.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1_encryption_parameters.html">EncryptionParameters</a> for more information about <a class="el" href="classseal_1_1_ciphertext.html#a988a73d6c998663fa888cb5af0c30184">parms_id</a>. </dd></dl>

</div>
</div>
<a id="a988a73d6c998663fa888cb5af0c30184" name="a988a73d6c998663fa888cb5af0c30184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988a73d6c998663fa888cb5af0c30184">&#9670;&#160;</a></span>parms_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD parms_id_type &amp; seal::Ciphertext::parms_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to parms_id.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1_encryption_parameters.html">EncryptionParameters</a> for more information about <a class="el" href="classseal_1_1_ciphertext.html#a988a73d6c998663fa888cb5af0c30184">parms_id</a>. </dd></dl>

</div>
</div>
<a id="aa1f5952371e98c9831ebe825a566234a" name="aa1f5952371e98c9831ebe825a566234a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f5952371e98c9831ebe825a566234a">&#9670;&#160;</a></span>poly_modulus_degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::size_t seal::Ciphertext::poly_modulus_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the degree of the polynomial modulus of the associated encryption parameters. This directly affects the allocation size of the ciphertext. </p>

</div>
</div>
<a id="a151a5b5d88fb0be12d6542efecdd8cac" name="a151a5b5d88fb0be12d6542efecdd8cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151a5b5d88fb0be12d6542efecdd8cac">&#9670;&#160;</a></span>pool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> seal::Ciphertext::pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the currently used <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>. </p>

</div>
</div>
<a id="a3eb26786de6ee2f17e162bfaf3f90a9f" name="a3eb26786de6ee2f17e162bfaf3f90a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb26786de6ee2f17e162bfaf3f90a9f">&#9670;&#160;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Ciphertext::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets the ciphertext. This function releases any memory allocated by the ciphertext, returning it to the memory pool. It also sets all encryption parameter specific size information to zero. </p>

</div>
</div>
<a id="ae9b5dab550e491ebab245bb776ebbbf3" name="ae9b5dab550e491ebab245bb776ebbbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b5dab550e491ebab245bb776ebbbf3">&#9670;&#160;</a></span>reserve() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Ciphertext::reserve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates enough memory to accommodate the backing array of a ciphertext with given capacity. In addition to the capacity, the allocation size is determined by the encryption parameters corresponing to the given parms_id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>The parms_id corresponding to the encryption parameters to be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_capacity</td><td>The capacity </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if size_capacity is less than 2 or too large </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c4d03f9e85e060641c9799c1cec3a72" name="a9c4d03f9e85e060641c9799c1cec3a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4d03f9e85e060641c9799c1cec3a72">&#9670;&#160;</a></span>reserve() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Ciphertext::reserve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates enough memory to accommodate the backing array of a ciphertext with given capacity. In addition to the capacity, the allocation size is determined by the highest-level parameters associated to the given <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_capacity</td><td>The capacity </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if size_capacity is less than 2 or too large </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1891148112ea9dccd8cf621fd4212bde" name="a1891148112ea9dccd8cf621fd4212bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1891148112ea9dccd8cf621fd4212bde">&#9670;&#160;</a></span>reserve() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Ciphertext::reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates enough memory to accommodate the backing array of a ciphertext with given capacity. In addition to the capacity, the allocation size is determined by the current encryption parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size_capacity</td><td>The capacity </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if size_capacity is less than 2 or too large </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the encryption parameters are not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b25806bea9a3d7d3a180e8a0f98848e" name="a2b25806bea9a3d7d3a180e8a0f98848e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b25806bea9a3d7d3a180e8a0f98848e">&#9670;&#160;</a></span>resize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Ciphertext::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resizes the ciphertext to given size, reallocating if the capacity of the ciphertext is too small. The ciphertext parameters are determined by the given <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> and parms_id.</p>
<p>This function is mainly intended for internal use and is called automatically by functions such as <a class="el" href="classseal_1_1_evaluator.html#ab5847bb2d26378a8aea60159e1980aab">Evaluator::multiply</a> and <a class="el" href="classseal_1_1_evaluator.html#ad326c409fe3c8cf7c741de44f6980941">Evaluator::relinearize</a>. A normal user should never have a reason to manually resize a ciphertext.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>The parms_id corresponding to the encryption parameters to be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The new size </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if size is less than 2 or too large </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69d815ba720159b1c2cbcee98a5ff3b6" name="a69d815ba720159b1c2cbcee98a5ff3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d815ba720159b1c2cbcee98a5ff3b6">&#9670;&#160;</a></span>resize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Ciphertext::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the ciphertext to given size, reallocating if the capacity of the ciphertext is too small. The ciphertext parameters are determined by the highest-level parameters associated to the given <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a>.</p>
<p>This function is mainly intended for internal use and is called automatically by functions such as <a class="el" href="classseal_1_1_evaluator.html#ab5847bb2d26378a8aea60159e1980aab">Evaluator::multiply</a> and <a class="el" href="classseal_1_1_evaluator.html#ad326c409fe3c8cf7c741de44f6980941">Evaluator::relinearize</a>. A normal user should never have a reason to manually resize a ciphertext.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The new size </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if size is less than 2 or too large </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fd34137f1afab52cc33192b1e730278" name="a2fd34137f1afab52cc33192b1e730278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd34137f1afab52cc33192b1e730278">&#9670;&#160;</a></span>resize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::Ciphertext::resize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the ciphertext to given size, reallocating if the capacity of the ciphertext is too small.</p>
<p>This function is mainly intended for internal use and is called automatically by functions such as <a class="el" href="classseal_1_1_evaluator.html#ab5847bb2d26378a8aea60159e1980aab">Evaluator::multiply</a> and <a class="el" href="classseal_1_1_evaluator.html#ad326c409fe3c8cf7c741de44f6980941">Evaluator::relinearize</a>. A normal user should never have a reason to manually resize a ciphertext.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The new size </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if size is less than 2 or too large </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f3a0d65ddace1a349dc316503559466" name="a4f3a0d65ddace1a349dc316503559466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3a0d65ddace1a349dc316503559466">&#9670;&#160;</a></span>save() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff seal::Ciphertext::save </td>
          <td>(</td>
          <td class="paramtype">seal_byte *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compr_mode_type&#160;</td>
          <td class="paramname"><em>compr_mode</em> = <code><a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves the ciphertext to a given memory location. The output is in binary format and is not human-readable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>The memory location to write the ciphertext to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes available in the given memory location </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compr_mode</td><td>The desired compression mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if out is null or if size is too small to contain a SEALHeader, or if the compression mode is not supported </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the data to be saved is invalid, or if compression failed </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if I/O operations failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebc1c076290039e6de34764d7f722bba" name="aebc1c076290039e6de34764d7f722bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc1c076290039e6de34764d7f722bba">&#9670;&#160;</a></span>save() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff seal::Ciphertext::save </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compr_mode_type&#160;</td>
          <td class="paramname"><em>compr_mode</em> = <code><a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves the ciphertext to an output stream. The output is in binary format and not human-readable. The output stream must have the "binary" flag set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stream</td><td>The stream to save the ciphertext to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compr_mode</td><td>The desired compression mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the compression mode is not supported </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the data to be saved is invalid, or if compression failed </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if I/O operations failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82469a60fb4805d9f28358c3b5e980d2" name="a82469a60fb4805d9f28358c3b5e980d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82469a60fb4805d9f28358c3b5e980d2">&#9670;&#160;</a></span>save_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">streamoff seal::Ciphertext::save_size </td>
          <td>(</td>
          <td class="paramtype">compr_mode_type&#160;</td>
          <td class="paramname"><em>compr_mode</em> = <code><a class="el" href="classseal_1_1_serialization.html#ac61148d45a46cf52709cbf4ddd8d2631">Serialization::compr_mode_default</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an upper bound on the size of the ciphertext, as if it was written to an output stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compr_mode</td><td>The compression mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the compression mode is not supported </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the size does not fit in the return type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a080d2e856faa5b617bda9e280824192d" name="a080d2e856faa5b617bda9e280824192d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080d2e856faa5b617bda9e280824192d">&#9670;&#160;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD const double &amp; seal::Ciphertext::scale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant reference to the scale. This is only needed when using the CKKS encryption scheme. </p>

</div>
</div>
<a id="a07bc454e13298b1416d238f5ec85fc1c" name="a07bc454e13298b1416d238f5ec85fc1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bc454e13298b1416d238f5ec85fc1c">&#9670;&#160;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD double &amp; seal::Ciphertext::scale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the scale. This is only needed when using the CKKS encryption scheme. The user should have little or no reason to ever change the scale by hand. </p>

</div>
</div>
<a id="a7ccc1a32a309ce4a72bf6622f79b2096" name="a7ccc1a32a309ce4a72bf6622f79b2096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccc1a32a309ce4a72bf6622f79b2096">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::size_t seal::Ciphertext::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size of the ciphertext. </p>

</div>
</div>
<a id="a6ed9c8dd55f83d0494d9b57dd2f0a7b8" name="a6ed9c8dd55f83d0494d9b57dd2f0a7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed9c8dd55f83d0494d9b57dd2f0a7b8">&#9670;&#160;</a></span>size_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::size_t seal::Ciphertext::size_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the capacity of the allocation. This means the largest size of the ciphertext that can be stored in the current allocation with the current encryption parameters. </p>

</div>
</div>
<a id="ac3e36764d9c6795693ad7de92f9856ec" name="ac3e36764d9c6795693ad7de92f9856ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e36764d9c6795693ad7de92f9856ec">&#9670;&#160;</a></span>unsafe_load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff seal::Ciphertext::unsafe_load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const seal_byte *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads a ciphertext from a given memory location overwriting the current ciphertext. No checking of the validity of the ciphertext data against encryption parameters is performed. This function should not be used unless the ciphertext comes from a fully trusted source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>The memory location to load the ciphertext from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes available in the given memory location </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if in is null or if size is too small to contain a SEALHeader </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the data cannot be loaded by this version of Microsoft SEAL, if the loaded data is invalid, or if decompression failed </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if I/O operations failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a584429fcc0b3a2e6b80a8d94476ac03d" name="a584429fcc0b3a2e6b80a8d94476ac03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584429fcc0b3a2e6b80a8d94476ac03d">&#9670;&#160;</a></span>unsafe_load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamoff seal::Ciphertext::unsafe_load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads a ciphertext from an input stream overwriting the current ciphertext. No checking of the validity of the ciphertext data against encryption parameters is performed. This function should not be used unless the ciphertext comes from a fully trusted source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream to load the ciphertext from </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the data cannot be loaded by this version of Microsoft SEAL, if the loaded data is invalid, or if decompression failed </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if I/O operations failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>seal/<a class="el" href="ciphertext_8h_source.html">ciphertext.h</a></li>
<li>seal/ciphertext.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
