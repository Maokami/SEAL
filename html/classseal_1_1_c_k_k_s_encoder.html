<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEAL: seal::CKKSEncoder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SEAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>seal</b></li><li class="navelem"><a class="el" href="classseal_1_1_c_k_k_s_encoder.html">CKKSEncoder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseal_1_1_c_k_k_s_encoder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">seal::CKKSEncoder Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ckks_8h_source.html">ckks.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a49f5e2ea8c212ed45d73f0fe41baf81e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_c_k_k_s_encoder.html#a49f5e2ea8c212ed45d73f0fe41baf81e">CKKSEncoder</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context)</td></tr>
<tr class="separator:a49f5e2ea8c212ed45d73f0fe41baf81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71758c23292bee1f5056c87f02443c30"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;                            std::is_same&lt;std::remove_cv_t&lt;T&gt;, double&gt;::value ||                            std::is_same&lt;std::remove_cv_t&lt;T&gt;, std::complex&lt;double&gt;&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a71758c23292bee1f5056c87f02443c30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseal_1_1_c_k_k_s_encoder.html#a71758c23292bee1f5056c87f02443c30">encode</a> (const std::vector&lt; T &gt; &amp;values, parms_id_type parms_id, double scale, <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;destination, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:a71758c23292bee1f5056c87f02443c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94782e19c22991b95e640067cf4e646"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;                            std::is_same&lt;std::remove_cv_t&lt;T&gt;, double&gt;::value ||                            std::is_same&lt;std::remove_cv_t&lt;T&gt;, std::complex&lt;double&gt;&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ae94782e19c22991b95e640067cf4e646"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseal_1_1_c_k_k_s_encoder.html#ae94782e19c22991b95e640067cf4e646">encode</a> (const std::vector&lt; T &gt; &amp;values, double scale, <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;destination, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:ae94782e19c22991b95e640067cf4e646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b555818b36dcb44fa58217d764a871"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_c_k_k_s_encoder.html#a24b555818b36dcb44fa58217d764a871">encode</a> (double value, parms_id_type parms_id, double scale, <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;destination, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:a24b555818b36dcb44fa58217d764a871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980de83750fca2c983c6bca1b43657c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_c_k_k_s_encoder.html#a980de83750fca2c983c6bca1b43657c6">encode</a> (double value, double scale, <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;destination, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:a980de83750fca2c983c6bca1b43657c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ff06c41def8626ed6d17a76a27add1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_c_k_k_s_encoder.html#a64ff06c41def8626ed6d17a76a27add1">encode</a> (std::complex&lt; double &gt; value, parms_id_type parms_id, double scale, <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;destination, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:a64ff06c41def8626ed6d17a76a27add1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa61623d599b26770ad7fdea92aa3cfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_c_k_k_s_encoder.html#aaa61623d599b26770ad7fdea92aa3cfe">encode</a> (std::complex&lt; double &gt; value, double scale, <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;destination, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:aaa61623d599b26770ad7fdea92aa3cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560dd9d10a58fed04ac259e3e22c56fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_c_k_k_s_encoder.html#a560dd9d10a58fed04ac259e3e22c56fc">encode</a> (std::int64_t value, parms_id_type parms_id, <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;destination) const</td></tr>
<tr class="separator:a560dd9d10a58fed04ac259e3e22c56fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047ea623797b251386ae9fe0c6220491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_c_k_k_s_encoder.html#a047ea623797b251386ae9fe0c6220491">encode</a> (std::int64_t value, <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;destination) const</td></tr>
<tr class="separator:a047ea623797b251386ae9fe0c6220491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f43d6391f41d65b22cf68677442785e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;                            std::is_same&lt;std::remove_cv_t&lt;T&gt;, double&gt;::value ||                            std::is_same&lt;std::remove_cv_t&lt;T&gt;, std::complex&lt;double&gt;&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a8f43d6391f41d65b22cf68677442785e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classseal_1_1_c_k_k_s_encoder.html#a8f43d6391f41d65b22cf68677442785e">decode</a> (const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;plain, std::vector&lt; T &gt; &amp;destination, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:a8f43d6391f41d65b22cf68677442785e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324bf43b23f2869bad124a891ae67871"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_c_k_k_s_encoder.html#a324bf43b23f2869bad124a891ae67871">slot_count</a> () const noexcept</td></tr>
<tr class="separator:a324bf43b23f2869bad124a891ae67871"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides functionality for encoding vectors of complex or real numbers into plaintext polynomials to be encrypted and computed on using the CKKS scheme. If the polynomial modulus degree is N, then <a class="el" href="classseal_1_1_c_k_k_s_encoder.html">CKKSEncoder</a> converts vectors of N/2 complex numbers into plaintext elements. Homomorphic operations performed on such encrypted vectors are applied coefficient (slot-)wise, enabling powerful SIMD functionality for computations that are vectorizable. This functionality is often called "batching" in the homomorphic encryption literature.</p>
<dl class="section user"><dt>Mathematical Background</dt><dd>Mathematically speaking, if the polynomial modulus is X^N+1, N is a power of two, the <a class="el" href="classseal_1_1_c_k_k_s_encoder.html">CKKSEncoder</a> implements an approximation of the canonical embedding of the ring of integers Z[X]/(X^N+1) into C^(N/2), where C denotes the complex numbers. The Galois group of the extension is (Z/2NZ)* ~= Z/2Z x Z/(N/2) whose action on the primitive roots of unity modulo coeff_modulus is easy to describe. Since the batching slots correspond 1-to-1 to the primitive roots of unity, applying Galois automorphisms on the plaintext acts by permuting the slots. By applying generators of the two cyclic subgroups of the Galois group, we can effectively enable cyclic rotations and complex conjugations of the encrypted complex vectors. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a49f5e2ea8c212ed45d73f0fe41baf81e" name="a49f5e2ea8c212ed45d73f0fe41baf81e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f5e2ea8c212ed45d73f0fe41baf81e">&#9670;&#160;</a></span>CKKSEncoder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">seal::CKKSEncoder::CKKSEncoder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classseal_1_1_c_k_k_s_encoder.html">CKKSEncoder</a> instance initialized with the specified <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if scheme is not scheme_type::CKKS </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8f43d6391f41d65b22cf68677442785e" name="a8f43d6391f41d65b22cf68677442785e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f43d6391f41d65b22cf68677442785e">&#9670;&#160;</a></span>decode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;                            std::is_same&lt;std::remove_cv_t&lt;T&gt;, double&gt;::value ||                            std::is_same&lt;std::remove_cv_t&lt;T&gt;, std::complex&lt;double&gt;&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::CKKSEncoder::decode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decodes a plaintext polynomial into double-precision floating-point real or complex numbers. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Vector value type (double or std::complex&lt;double&gt;) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext to decode </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The vector to be overwritten with the values in the slots </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not in NTT form or is invalid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae94782e19c22991b95e640067cf4e646" name="ae94782e19c22991b95e640067cf4e646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94782e19c22991b95e640067cf4e646">&#9670;&#160;</a></span>encode() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;                            std::is_same&lt;std::remove_cv_t&lt;T&gt;, double&gt;::value ||                            std::is_same&lt;std::remove_cv_t&lt;T&gt;, std::complex&lt;double&gt;&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::CKKSEncoder::encode </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes a vector of double-precision floating-point real or complex numbers into a plaintext polynomial. Append zeros if vector size is less than N/2. The encryption parameters used are the top level parameters for the given context. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Vector value type (double or std::complex&lt;double&gt;) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>The vector of double-precision floating-point numbers (of type T) to encode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>Scaling parameter defining encoding precision </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The plaintext polynomial to overwrite with the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if values has invalid size </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if scale is not strictly positive </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encoding is too large for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71758c23292bee1f5056c87f02443c30" name="a71758c23292bee1f5056c87f02443c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71758c23292bee1f5056c87f02443c30">&#9670;&#160;</a></span>encode() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;                            std::is_same&lt;std::remove_cv_t&lt;T&gt;, double&gt;::value ||                            std::is_same&lt;std::remove_cv_t&lt;T&gt;, std::complex&lt;double&gt;&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::CKKSEncoder::encode </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes a vector of double-precision floating-point real or complex numbers into a plaintext polynomial. Append zeros if vector size is less than N/2. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Vector value type (double or std::complex&lt;double&gt;) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>The vector of double-precision floating-point numbers (of type T) to encode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>parms_id determining the encryption parameters to be used by the result plaintext </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>Scaling parameter defining encoding precision </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The plaintext polynomial to overwrite with the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if values has invalid size </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if scale is not strictly positive </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encoding is too large for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a980de83750fca2c983c6bca1b43657c6" name="a980de83750fca2c983c6bca1b43657c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980de83750fca2c983c6bca1b43657c6">&#9670;&#160;</a></span>encode() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::CKKSEncoder::encode </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes a double-precision floating-point real number into a plaintext polynomial. The number repeats for N/2 times to fill all slots. The encryption parameters used are the top level parameters for the given context. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The double-precision floating-point number to encode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>Scaling parameter defining encoding precision </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The plaintext polynomial to overwrite with the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if scale is not strictly positive </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encoding is too large for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24b555818b36dcb44fa58217d764a871" name="a24b555818b36dcb44fa58217d764a871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b555818b36dcb44fa58217d764a871">&#9670;&#160;</a></span>encode() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::CKKSEncoder::encode </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes a double-precision floating-point real number into a plaintext polynomial. The number repeats for N/2 times to fill all slots. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The double-precision floating-point number to encode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>parms_id determining the encryption parameters to be used by the result plaintext </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>Scaling parameter defining encoding precision </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The plaintext polynomial to overwrite with the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if scale is not strictly positive </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encoding is too large for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa61623d599b26770ad7fdea92aa3cfe" name="aaa61623d599b26770ad7fdea92aa3cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa61623d599b26770ad7fdea92aa3cfe">&#9670;&#160;</a></span>encode() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::CKKSEncoder::encode </td>
          <td>(</td>
          <td class="paramtype">std::complex&lt; double &gt;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes a double-precision complex number into a plaintext polynomial. Append zeros to fill all slots. The encryption parameters used are the top level parameters for the given context. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The double-precision complex number to encode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>Scaling parameter defining encoding precision </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The plaintext polynomial to overwrite with the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if scale is not strictly positive </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encoding is too large for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64ff06c41def8626ed6d17a76a27add1" name="a64ff06c41def8626ed6d17a76a27add1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ff06c41def8626ed6d17a76a27add1">&#9670;&#160;</a></span>encode() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::CKKSEncoder::encode </td>
          <td>(</td>
          <td class="paramtype">std::complex&lt; double &gt;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes a double-precision complex number into a plaintext polynomial. Append zeros to fill all slots. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The double-precision complex number to encode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>parms_id determining the encryption parameters to be used by the result plaintext </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>Scaling parameter defining encoding precision </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The plaintext polynomial to overwrite with the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if scale is not strictly positive </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if encoding is too large for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a560dd9d10a58fed04ac259e3e22c56fc" name="a560dd9d10a58fed04ac259e3e22c56fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560dd9d10a58fed04ac259e3e22c56fc">&#9670;&#160;</a></span>encode() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::CKKSEncoder::encode </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">parms_id_type&#160;</td>
          <td class="paramname"><em>parms_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes an integer number into a plaintext polynomial without any scaling. The number repeats for N/2 times to fill all slots. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer number to encode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parms_id</td><td>parms_id determining the encryption parameters to be used by the result plaintext </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The plaintext polynomial to overwrite with the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if parms_id is not valid for the encryption parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a047ea623797b251386ae9fe0c6220491" name="a047ea623797b251386ae9fe0c6220491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047ea623797b251386ae9fe0c6220491">&#9670;&#160;</a></span>encode() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void seal::CKKSEncoder::encode </td>
          <td>(</td>
          <td class="paramtype">std::int64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encodes an integer number into a plaintext polynomial without any scaling. The number repeats for N/2 times to fill all slots. The encryption parameters used are the top level parameters for the given context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer number to encode </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The plaintext polynomial to overwrite with the result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a324bf43b23f2869bad124a891ae67871" name="a324bf43b23f2869bad124a891ae67871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324bf43b23f2869bad124a891ae67871">&#9670;&#160;</a></span>slot_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD std::size_t seal::CKKSEncoder::slot_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of complex numbers encoded. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>seal/<a class="el" href="ckks_8h_source.html">ckks.h</a></li>
<li>seal/ckks.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
