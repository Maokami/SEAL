<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEAL: seal::util::SEALIterBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SEAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>seal</b></li><li class="navelem"><b>util</b></li><li class="navelem"><a class="el" href="classseal_1_1util_1_1_s_e_a_l_iter_base.html">SEALIterBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">seal::util::SEALIterBase Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="iterator_8h_source.html">iterator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for seal::util::SEALIterBase:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classseal_1_1util_1_1_s_e_a_l_iter_base.png" usemap="#seal::util::SEALIterBase_map" alt=""/>
  <map id="seal::util::SEALIterBase_map" name="seal::util::SEALIterBase_map">
<area href="classseal_1_1util_1_1_const_poly_iter.html" alt="seal::util::ConstPolyIter" shape="rect" coords="241,56,472,80"/>
<area href="classseal_1_1util_1_1_const_r_n_s_iter.html" alt="seal::util::ConstRNSIter" shape="rect" coords="241,112,472,136"/>
<area href="classseal_1_1util_1_1_iter_tuple_3_01_s_e_a_l_iter_01_4.html" alt="seal::util::IterTuple&lt; SEALIter &gt;" shape="rect" coords="241,168,472,192"/>
<area href="classseal_1_1util_1_1_iter_tuple_3_01_s_e_a_l_iter_00_01_rest_8_8_8_01_4.html" alt="seal::util::IterTuple&lt; SEALIter, Rest... &gt;" shape="rect" coords="241,224,472,248"/>
<area href="classseal_1_1util_1_1_poly_iter.html" alt="seal::util::PolyIter" shape="rect" coords="241,280,472,304"/>
<area href="classseal_1_1util_1_1_ptr_iter_3_01_t_01_5_01_4.html" alt="seal::util::PtrIter&lt; T * &gt;" shape="rect" coords="241,336,472,360"/>
<area href="classseal_1_1util_1_1_r_n_s_iter.html" alt="seal::util::RNSIter" shape="rect" coords="241,392,472,416"/>
<area href="classseal_1_1util_1_1_seq_iter.html" alt="seal::util::SeqIter&lt; T, typename &gt;" shape="rect" coords="241,448,472,472"/>
<area href="classseal_1_1util_1_1_stride_iter_3_01_t_01_5_01_4.html" alt="seal::util::StrideIter&lt; T * &gt;" shape="rect" coords="241,504,472,528"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section user"><dt>PolyIter, RNSIter, and CoeffIter</dt><dd>In this file we define a set of custom iterator classes ("SEAL iterators") that are used throughout Microsoft SEAL for easier iteration over ciphertext polynomials, their RNS components, and the coefficients in the RNS components. All SEAL iterators satisfy the C++ LegacyRandomAccessIterator requirements. SEAL iterators are ideal to use with the SEAL_ITERATE macro, which expands to std::for_each_n in C++17 and to seal::util::seal_for_each_n in C++14. All SEAL iterators derive from <a class="el" href="classseal_1_1util_1_1_s_e_a_l_iter_base.html">SEALIterBase</a>.</dd></dl>
<p>The most important SEAL iterator classes behave as illustrated by the following diagram:</p>
<p>+----------------&mdash;+ | <a class="el" href="classseal_1_1util_1_1_pointer.html">Pointer</a> &amp; Size | Construct +--------------&mdash;+ | or <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> |---------&mdash;&gt;| (Const)<a class="el" href="classseal_1_1util_1_1_poly_iter.html">PolyIter</a> | Iterates over RNS polynomials in a ciphertext +----------------&mdash;+ +-----&mdash;+-----&mdash;+ (coeff_modulus_size-many RNS components) | | | Dereference | | v +-------------&mdash;+ Construct +-------------&mdash;+ | <a class="el" href="classseal_1_1util_1_1_pointer.html">Pointer</a> &amp; Size |----------&mdash;&gt;| (Const)<a class="el" href="classseal_1_1util_1_1_r_n_s_iter.html">RNSIter</a> | Iterates over RNS components in an RNS polynomial +-------------&mdash;+ +----&mdash;+-----&mdash;+ (poly_modulus_degree-many coefficients) | | | Dereference | | v +-------------&mdash;+ Construct +---------------&mdash;+ | <a class="el" href="classseal_1_1util_1_1_pointer.html">Pointer</a> &amp; Size |---------&mdash;&gt;| (Const)CoeffIter | Iterates over coefficients (std::uint64_t) in a single +-------------&mdash;+ +------&mdash;+-----&mdash;+ RNS polynomial component | | | Dereference | | v +----------------------&mdash;+ | (const) std::uint64_t &amp; | +----------------------&mdash;+</p>
<dl class="section user"><dt>PtrIter and StrideIter</dt><dd><a class="el" href="classseal_1_1util_1_1_ptr_iter_3_01_t_01_5_01_4.html">PtrIter&lt;T *&gt;</a> and <a class="el" href="classseal_1_1util_1_1_stride_iter_3_01_t_01_5_01_4.html">StrideIter&lt;T *&gt;</a> are both templated SEAL iterators that wrap raw pointers. The difference between these two types is that advancing <a class="el" href="classseal_1_1util_1_1_ptr_iter_3_01_t_01_5_01_4.html">PtrIter&lt;T *&gt;</a> always advances the wrapped pointer by one, whereas the step size (stride) can be set to be anything for a <a class="el" href="classseal_1_1util_1_1_stride_iter_3_01_t_01_5_01_4.html">StrideIter&lt;T *&gt;</a>. CoeffIter is a typedef of <a class="el" href="classseal_1_1util_1_1_ptr_iter.html">PtrIter&lt;std::uint64_t *&gt;</a> and and <a class="el" href="classseal_1_1util_1_1_r_n_s_iter.html">RNSIter</a> is almost the same as StrideIter&lt;std::uint64_t *&gt;, but still a different type.</dd></dl>
<p>+-------&mdash;+ Construct +----------------&mdash;+ | MyType * |----------&mdash;&gt;| PtrIter&lt;MyType *&gt; | Simple wrapper for raw pointers +-------&mdash;+ +-&mdash;+-------&mdash;+&mdash;+ | | | | Dereference | | PtrIter&lt;MyType *&gt;::ptr() | | or implicit conversion | | v v +-------&mdash;+ +-------&mdash;+ | MyType &amp; | | MyType * | +-------&mdash;+ +-------&mdash;+</p>
<p>+-------&mdash;+ Construct +-------------------&mdash;+ | MyType * |----------&mdash;&gt;| StrideIter&lt;MyType *&gt; | Simple wrapper for raw pointers with custom stride size +-------&mdash;+ +--&mdash;+-------&mdash;+--&mdash;+ | | | | Dereference | | StrideIter&lt;MyType *&gt;::ptr() | | or implicit conversion | | v v +-------&mdash;+ +-------&mdash;+ | MyType &amp; | | MyType * | +-------&mdash;+ +-------&mdash;+</p>
<dl class="section user"><dt>IterTuple</dt><dd>An extremely useful template class is the (variadic) IterTuple&lt;...&gt; that allows multiple SEAL iterators to be zipped together. An <a class="el" href="classseal_1_1util_1_1_iter_tuple.html">IterTuple</a> is itself a SEAL iterator and nested <a class="el" href="classseal_1_1util_1_1_iter_tuple.html">IterTuple</a> types are used commonly in the library. Dereferencing an <a class="el" href="classseal_1_1util_1_1_iter_tuple.html">IterTuple</a> always yields an std::tuple, with each <a class="el" href="classseal_1_1util_1_1_iter_tuple.html">IterTuple</a> element dereferenced. Since an <a class="el" href="classseal_1_1util_1_1_iter_tuple.html">IterTuple</a> can be constructed from an std::tuple holding the respective single-parameter constructor arguments for each iterator, the dereferenced std::tuple can often be directly passed on to functions expecting an <a class="el" href="classseal_1_1util_1_1_iter_tuple.html">IterTuple</a>.</dd></dl>
<p>The individual components of an <a class="el" href="classseal_1_1util_1_1_iter_tuple.html">IterTuple</a> can be accessed with the seal::util::get&lt;i&gt;(...) functions. The behavior of <a class="el" href="classseal_1_1util_1_1_iter_tuple.html">IterTuple</a> is summarized in the following diagram: </p><pre class="fragment"> +-----------------------------------------+
 | IterTuple&lt;PolyIter, RNSIter, CoeffIter&gt; |
 +--------------------+--------------------+
                      |
                      |
                      | Dereference
                      |
                      |
                      v
</pre><p> +-----------------------------------------------&mdash;+ | std::tuple&lt;RNSIter, CoeffIter, std::uint64_t &amp;&gt;&gt; | +---&mdash;+----------------&mdash;+----------------&mdash;+&mdash;+ | | | | | | | std::get&lt;0&gt; | std::get&lt;1&gt; | std::get&lt;2&gt; | | | | | | v v v +----------&mdash;+ +------------&mdash;+ +--------------&mdash;+ | <a class="el" href="classseal_1_1util_1_1_r_n_s_iter.html">RNSIter</a> | | CoeffIter | | std::uint64_t &amp; | +----------&mdash;+ +------------&mdash;+ +--------------&mdash;+</p>
<p>Sometimes we have to use multiple nested iterator tuples. In this case accessing the nested iterators can be tedious with nested get&lt;...&gt; calls. Consider the following, where encrypted1 and encrypted2 are Ciphertexts and destination is either a <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> or a <a class="el" href="classseal_1_1util_1_1_poly_iter.html">PolyIter</a>:</p>
<p>IterTuple&lt;PolyIter, PolyIter&gt; I(encrypted1, encrypted2); IterTuple&lt;decltype(I), PolyIter&gt; J(I, destination); auto encrypted1_iter = get&lt;0&gt;(get&lt;0&gt;(J)); auto encrypted2_iter = get&lt;1&gt;(get&lt;0&gt;(J));</p>
<p>An easier way is to use another form of get&lt;...&gt; that accepts multiple indices and accesses the structure in a nested manner. For example, in the above we could also write:</p>
<p>auto encrypted1_iter = get&lt;0, 0&gt;(J)); auto encrypted2_iter = get&lt;0, 1&gt;(J));</p>
<p>Note that the innermost tuple index appears first in the list, i.e. the order is reversed from what appears in a nested get&lt;...&gt; call. The reason for this reversal is that, when deducing what the iterators are, one first examines at the innermost scope, and last the outermost scope, corresponding now to the order of the indices. We have also provided similar functions for nested std::tuple objects, which is necessary when accessing the dereferencing of a nested <a class="el" href="classseal_1_1util_1_1_iter_tuple.html">IterTuple</a>.</p>
<dl class="section user"><dt>Typedefs for common PtrIter types</dt><dd>It is very common to use the types PtrIter&lt;Modulus *&gt; and PtrIter&lt;NTTTables *&gt;. To simplify the notation, we have set up typedefs for these: ModulusIter and NTTTablesIter. There are also constant versions ConstModulusIter and ConstNTTTablesIter, wrapping pointers to constant <a class="el" href="classseal_1_1_modulus.html">Modulus</a> and <a class="el" href="classseal_1_1util_1_1_n_t_t_tables.html">NTTTables</a> instead.</dd></dl>
<dl class="section user"><dt>Creating SEAL iterators</dt><dd>Iterators are easiest to create using the variadic iter function that, when given one or more arguments that can naturally be converted to SEAL iterators, outputs an appropriate iterator, or iterator tuple. Consider again the code snippet above, and how confusing the template parameters can become to write. Instead, we can simply write:</dd></dl>
<p>auto I = iter(encrypted1, encrypted2); auto J = iter(I, destination); auto encrypted1_iter = get&lt;0, 0&gt;(J)); auto encrypted2_iter = get&lt;0, 1&gt;(J));</p>
<p>There are three ways to create IterTuples from the iter function. The first way is by passing an <a class="el" href="classseal_1_1util_1_1_iter_tuple.html">IterTuple</a> as input, in which case iter outputs a copy of it; there should be no reason to do this. The second way is by passing a variadic set of constructor arguments; iter will output an <a class="el" href="classseal_1_1util_1_1_iter_tuple.html">IterTuple</a> consisting of SEAL iterators that are compatible with the given constructor arguments. The third way is by passing a std::tuple consisting of a variadic set of constructor arguments; the behavior is as in the second way.</p>
<dl class="section user"><dt>Reversing direction with ReverseIter</dt><dd>In addition to the iterator types described above, we provide ReverseIter&lt;SEALIter&gt; that reverses the direction of iteration. ReverseIter&lt;SEALIter&gt; dereferences to the same type as SEALIter: for example, dereferencing ReverseIter&lt;RNSIter&gt; results in CoeffIter, not ReverseIter&lt;CoeffIter&gt;.</dd></dl>
<p>It is easy to create a <a class="el" href="classseal_1_1util_1_1_reverse_iter.html">ReverseIter</a> from a given SEAL iterator using the function reverse_iter. For example, reverse_iter(encrypted) will return a ReverseIter&lt;PolyIter&gt; if encrypted is either a <a class="el" href="classseal_1_1util_1_1_poly_iter.html">PolyIter</a>, or a <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a>. When passed multiple arguments, reverse_iter returns an appropriate ReverseIter&lt;IterTuple&lt;...&gt;&gt;. For example, reverse_iter(encrypted1, encrypted2) returns ReverseIter&lt;IterTuple&lt;PolyIter, PolyIter&gt;&gt; if encrypted1 and encrypted2 are <a class="el" href="classseal_1_1util_1_1_poly_iter.html">PolyIter</a> or <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> objects.</p>
<dl class="section user"><dt>SEAL_ITERATE</dt><dd>SEAL iterators are made to be used with the SEAL_ITERATE macro to iterate over a certain number of steps, and for each step call a given lambda function. In C++17 SEAL_ITERATE expands to std::for_each_n, and in C++14 it expands to seal::util::seal_for_each_n &ndash; a custom implementation. For example, the following snippet appears in Evaluator::bfv_multiply:</dd></dl>
<p>SEAL_ITERATE(
    iter(encrypted1, encrypted1_q, encrypted1_Bsk),
    encrypted1_size,
    behz_extend_base_convert_to_ntt);</p>
<p>Here an IterTuple&lt;PolyIter, PolyIter, PolyIter&gt; is created with the iter function; the argument types are <a class="el" href="classseal_1_1_ciphertext.html">Ciphertext</a> (encrypted1), <a class="el" href="classseal_1_1util_1_1_poly_iter.html">PolyIter</a> (encrypted1_q), and <a class="el" href="classseal_1_1util_1_1_poly_iter.html">PolyIter</a> (encrypted1_Bsk). The iterator is advanced encrypted1_size times, and each time the lambda function behz_extend_base_convert_to_ntt is called with the iterator tuple dereferenced. The lambda function starts as follows:</p>
<p>auto behz_extend_base_convert_to_ntt = [&amp;](auto I) { set_poly(get&lt;0&gt;(I), coeff_count, base_q_size, get&lt;1&gt;(I)); ntt_negacyclic_harvey_lazy(get&lt;1&gt;(I), base_q_size, base_q_ntt_tables); ... });</p>
<p>Here the parameter I is of type IterTuple&lt;RNSIter, RNSIter, RNSIter&gt;. Inside the lambda function we first copy the RNS polynomial from get&lt;0&gt;(I) (encrypted1) to get&lt;1&gt;(I) (encrypted1_q) and transform it to NTT form. We use an overload of ntt_negacyclic_harvey_lazy that takes an <a class="el" href="classseal_1_1util_1_1_r_n_s_iter.html">RNSIter</a>, size of the RNS base, and ConstNTTTablesIter as arguments and converts each RNS component separately. Looking at <a class="el" href="ntt_8h_source.html">seal/util/ntt.h</a> we see that the function ntt_negacyclic_harvey_lazy is again implemented using SEAL_ITERATE. Specifically, it contains the following:</p>
<p>SEAL_ITERATE(iter(operand, tables), coeff_modulus_size, [&amp;](auto I) { ntt_negacyclic_harvey_lazy(get&lt;0&gt;(I), get&lt;1&gt;(I)); });</p>
<p>Here iter outputs an IterTuple&lt;RNSIter, ConstNTTTablesIter&gt;. In this case the lambda function to be called is defined inline. The argument I takes values IterTuple&lt;CoeffIter, const NTTTables *&gt;, and for each step the CoeffIter overload of ntt_negacyclic_harvey_lazy is called, with a reference to a matching <a class="el" href="classseal_1_1util_1_1_n_t_t_tables.html">NTTTables</a> object.</p>
<dl class="section user"><dt>Coding conventions</dt><dd>There are two important coding conventions in the above code snippets that are to be observed: <pre class="fragment">1. Use I, J, K, ... for the lambda function parameters representing SEAL iterators. This is compact and
   makes it very clear that the objects in question are SEAL iterators since such variable names should not
   be used in SEAL in any other context.
2. Lambda functions passed to SEAL_ITERATE should almost always (see 3.) take a parameter of type auto. This
   will produce simple looking code that performs well with the expected outcome.
3. The only exception to 2. is when SEAL_ITERATE operates on a single PtrIter&lt;T *&gt;: dereferencing returns a
   T &amp;, which may be important to forward by reference to the lambda function. For an example of this, see
   seal::util::ntt_negacyclic_harvey in seal/util/ntt.h, where the lambda function parameter is auto &amp;.

   Note: IterTuple&lt;PolyIter, CoeffIter&gt; will dereference to std::tuple&lt;RNSIter, std::uint64_t &amp;&gt;, which can
   safely be passed by value to the lambda function. Hence, a parameter of type auto in the lambda function
   will most likely work as expected.

   Note: Another approach that would always behave correctly is by using a forwarding reference auto &amp;&amp; as
   the lambda function parameter. However, we feel that this unnecessarily complicates the code for a minor
   benefit.
</pre> </dd></dl>
<dl class="section user"><dt>Iterator overloads of common functions</dt><dd>Some functions have overloads that directly take either CoeffIter, <a class="el" href="classseal_1_1util_1_1_r_n_s_iter.html">RNSIter</a>, or <a class="el" href="classseal_1_1util_1_1_poly_iter.html">PolyIter</a> inputs, and apply the operation in question to the entire structure as indicated by the iterator. For example, the function seal::util::negate_poly_coeffmod can negate a single RNS component modulo a given <a class="el" href="classseal_1_1_modulus.html">Modulus</a> (CoeffIter overload), an entire RNS polynomial modulo an array of matching <a class="el" href="classseal_1_1_modulus.html">Modulus</a> elements (<a class="el" href="classseal_1_1util_1_1_r_n_s_iter.html">RNSIter</a> overload), or an array of RNS polynomials (<a class="el" href="classseal_1_1util_1_1_poly_iter.html">PolyIter</a> overload).</dd></dl>
<dl class="section user"><dt>Indexing with SeqIter</dt><dd>Sometimes inside SEAL_ITERATE lambda functions it is convenient to know the index of the iteration. This can be done using a SeqIter&lt;T&gt; iterator. The template parameter is an arithmetic type for the index counter.</dd></dl>
<p>The easiest way to create <a class="el" href="classseal_1_1util_1_1_seq_iter.html">SeqIter</a> objects is using the seq_iter function. For example, seq_iter(0) returns a SeqIter&lt;int&gt; object with initial value 0. Alternatively, the iter function will detect arithmetic types passed to it and create <a class="el" href="classseal_1_1util_1_1_seq_iter.html">SeqIter</a> objects from them. For example, calling iter(0) is equivalent to calling seq_iter(0), and this works also for multi-argument calls to iter. Dereferencing a <a class="el" href="classseal_1_1util_1_1_seq_iter.html">SeqIter</a> object returns the current value. For opposite direction indexing, simply wrap a <a class="el" href="classseal_1_1util_1_1_seq_iter.html">SeqIter</a> into a <a class="el" href="classseal_1_1util_1_1_reverse_iter.html">ReverseIter</a>, or call reverse_iter directly with the start index.</p>
<dl class="section user"><dt>Note on allocations</dt><dd>In the future we hope to use the parallel version of std::for_each_n, introduced in C++17. For this to work, be mindful of how you use heap allocations in the lambda functions. Specifically, in heavy lambda functions it is probably a good idea to call seal::util::allocate inside the lambda function for any allocations needed, rather than using allocations captured from outside the lambda function.</dd></dl>
<dl class="section user"><dt>Iterators to temporary allocations</dt><dd>In many cases one may want to allocate a temporary buffer and create an iterator pointing to it. However, care must be taken to use the correct size parameters now both for the allocation, as well as for setting up the iterator. For this reason, we provide a few helpful macros that set up the <a class="el" href="classseal_1_1util_1_1_pointer.html">Pointer</a> and only expose the iterator to the function. For example, instead of writing the following error-prone code:</dd></dl>
<p>auto temp_alloc(allocate_poly_array(count, poly_modulus_degree, coeff_modulus_size, pool)); <a class="el" href="classseal_1_1util_1_1_poly_iter.html">PolyIter</a> temp(temp_alloc.get(), poly_modulus_degree, coeff_modulus_size);</p>
<p>we can simply write:</p>
<p>SEAL_ALLOCATE_GET_POLY_ITER(temp, count, poly_modulus_degree, coeff_modulus_size, pool);</p>
<p>However, the latter does not expose the name of the allocation itself. There are similar macros for allocating buffers and setting up <a class="el" href="classseal_1_1util_1_1_ptr_iter_3_01_t_01_5_01_4.html">PtrIter&lt;T *&gt;</a>, <a class="el" href="classseal_1_1util_1_1_stride_iter_3_01_t_01_5_01_4.html">StrideIter&lt;T *&gt;</a>, <a class="el" href="classseal_1_1util_1_1_r_n_s_iter.html">RNSIter</a>, and CoeffIter objects as well. </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>seal/util/<a class="el" href="iterator_8h_source.html">iterator.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
