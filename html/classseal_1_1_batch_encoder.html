<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SEAL: seal::BatchEncoder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SEAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>seal</b></li><li class="navelem"><a class="el" href="classseal_1_1_batch_encoder.html">BatchEncoder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classseal_1_1_batch_encoder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">seal::BatchEncoder Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="batchencoder_8h_source.html">batchencoder.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac23a0c59c183f6347746f472c8354452"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_batch_encoder.html#ac23a0c59c183f6347746f472c8354452">BatchEncoder</a> (const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;context)</td></tr>
<tr class="separator:ac23a0c59c183f6347746f472c8354452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541e7c0d2f3d79d9cb49dc989e4aa85f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_batch_encoder.html#a541e7c0d2f3d79d9cb49dc989e4aa85f">encode</a> (const std::vector&lt; std::uint64_t &gt; &amp;values, <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;destination) const</td></tr>
<tr class="separator:a541e7c0d2f3d79d9cb49dc989e4aa85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560d178d06530f154263308155bdc574"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_batch_encoder.html#a560d178d06530f154263308155bdc574">encode</a> (const std::vector&lt; std::int64_t &gt; &amp;values, <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;destination) const</td></tr>
<tr class="separator:a560d178d06530f154263308155bdc574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa152fb878d0f5e465f57a0658040898a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_batch_encoder.html#aa152fb878d0f5e465f57a0658040898a">decode</a> (const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;plain, std::vector&lt; std::uint64_t &gt; &amp;destination, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:aa152fb878d0f5e465f57a0658040898a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66e76ecca6cf32c48ace3d38df4189c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_batch_encoder.html#aa66e76ecca6cf32c48ace3d38df4189c">decode</a> (const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;plain, std::vector&lt; std::int64_t &gt; &amp;destination, <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pool=<a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()) const</td></tr>
<tr class="separator:aa66e76ecca6cf32c48ace3d38df4189c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94607373c39f0d3f6dccec9b8c31d02"><td class="memItemLeft" align="right" valign="top">SEAL_NODISCARD auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classseal_1_1_batch_encoder.html#aa94607373c39f0d3f6dccec9b8c31d02">slot_count</a> () const noexcept</td></tr>
<tr class="separator:aa94607373c39f0d3f6dccec9b8c31d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides functionality for CRT batching. If the polynomial modulus degree is N, and the plaintext modulus is a prime number T such that T is congruent to 1 modulo 2N, then <a class="el" href="classseal_1_1_batch_encoder.html">BatchEncoder</a> allows the plaintext elements to be viewed as 2-by-(N/2) matrices of integers modulo T. Homomorphic operations performed on such encrypted matrices are applied coefficient (slot) wise, enabling powerful SIMD functionality for computations that are vectorizable. This functionality is often called "batching" in the homomorphic encryption literature.</p>
<dl class="section user"><dt>Mathematical Background</dt><dd>Mathematically speaking, if the polynomial modulus is X^N+1, N is a power of two, and plain_modulus is a prime number T such that 2N divides T-1, then integers modulo T contain a primitive 2N-th root of unity and the polynomial X^N+1 splits into n distinct linear factors as X^N+1 = (X-a_1)*...*(X-a_N) mod T, where the constants a_1, ..., a_N are all the distinct primitive 2N-th roots of unity in integers modulo T. The Chinese Remainder Theorem (CRT) states that the plaintext space Z_T[X]/(X^N+1) in this case is isomorphic (as an algebra) to the N-fold direct product of fields Z_T. The isomorphism is easy to compute explicitly in both directions, which is what this class does. Furthermore, the Galois group of the extension is (Z/2NZ)* ~= Z/2Z x Z/(N/2)Z whose action on the primitive roots of unity is easy to describe. Since the batching slots correspond 1-to-1 to the primitive roots of unity, applying Galois automorphisms on the plaintext act by permuting the slots. By applying generators of the two cyclic subgroups of the Galois group, we can effectively view the plaintext as a 2-by-(N/2) matrix, and enable cyclic row rotations, and column rotations (row swaps).</dd></dl>
<dl class="section user"><dt>Valid Parameters</dt><dd>Whether batching can be used depends on whether the plaintext modulus has been chosen appropriately. Thus, to construct a <a class="el" href="classseal_1_1_batch_encoder.html">BatchEncoder</a> the user must provide an instance of <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> such that its associated <a class="el" href="classseal_1_1_encryption_parameter_qualifiers.html">EncryptionParameterQualifiers</a> object has the flags parameters_set and enable_batching set to true.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classseal_1_1_encryption_parameters.html">EncryptionParameters</a> for more information about encryption parameters. </dd>
<dd>
<a class="el" href="classseal_1_1_encryption_parameter_qualifiers.html">EncryptionParameterQualifiers</a> for more information about parameter qualifiers. </dd>
<dd>
<a class="el" href="classseal_1_1_evaluator.html">Evaluator</a> for rotating rows and columns of encrypted matrices. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac23a0c59c183f6347746f472c8354452" name="ac23a0c59c183f6347746f472c8354452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23a0c59c183f6347746f472c8354452">&#9670;&#160;</a></span>BatchEncoder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">seal::BatchEncoder::BatchEncoder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classseal_1_1_batch_encoder.html">BatchEncoder</a>. It is necessary that the encryption parameters given through the <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> object support batching.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classseal_1_1_s_e_a_l_context.html">SEALContext</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the encryption parameters are not valid for batching </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if scheme is not scheme_type::bfv </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa66e76ecca6cf32c48ace3d38df4189c" name="aa66e76ecca6cf32c48ace3d38df4189c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66e76ecca6cf32c48ace3d38df4189c">&#9670;&#160;</a></span>decode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::BatchEncoder::decode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inverse of encode. This function "unbatches" a given plaintext into a matrix of integers modulo the plaintext modulus, and stores the result in the destination parameter. The input plaintext must have degrees less than the polynomial modulus, and coefficients less than the plaintext modulus, i.e. it must be a valid plaintext for the encryption parameters. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext polynomial to unbatch </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The matrix to be overwritten with the values in the slots </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is in NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa152fb878d0f5e465f57a0658040898a" name="aa152fb878d0f5e465f57a0658040898a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa152fb878d0f5e465f57a0658040898a">&#9670;&#160;</a></span>decode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::BatchEncoder::decode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>plain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="classseal_1_1_memory_manager.html#afc62ce21ea02922446f3d15229b78fa5">MemoryManager::GetPool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inverse of encode. This function "unbatches" a given plaintext into a matrix of integers modulo the plaintext modulus, and stores the result in the destination parameter. The input plaintext must have degrees less than the polynomial modulus, and coefficients less than the plaintext modulus, i.e. it must be a valid plaintext for the encryption parameters. Dynamic memory allocations in the process are allocated from the memory pool pointed to by the given <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plain</td><td>The plaintext polynomial to unbatch </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The matrix to be overwritten with the values in the slots </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The <a class="el" href="classseal_1_1_memory_pool_handle.html">MemoryPoolHandle</a> pointing to a valid memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is not valid for the encryption parameters </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if plain is in NTT form </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if pool is uninitialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a560d178d06530f154263308155bdc574" name="a560d178d06530f154263308155bdc574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560d178d06530f154263308155bdc574">&#9670;&#160;</a></span>encode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::BatchEncoder::encode </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a plaintext from a given matrix. This function "batches" a given matrix of integers modulo the plaintext modulus into a plaintext element, and stores the result in the destination parameter. The input vector must have size at most equal to the degree of the polynomial modulus. The first half of the elements represent the first row of the matrix, and the second half represent the second row. The numbers in the matrix can be at most equal to the plaintext modulus for it to represent a valid plaintext.</p>
<p>If the destination plaintext overlaps the input values in memory, the behavior of this function is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>The matrix of integers modulo plaintext modulus to batch </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The plaintext polynomial to overwrite with the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if values is too large </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a541e7c0d2f3d79d9cb49dc989e4aa85f" name="a541e7c0d2f3d79d9cb49dc989e4aa85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541e7c0d2f3d79d9cb49dc989e4aa85f">&#9670;&#160;</a></span>encode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seal::BatchEncoder::encode </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classseal_1_1_plaintext.html">Plaintext</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a plaintext from a given matrix. This function "batches" a given matrix of integers modulo the plaintext modulus into a plaintext element, and stores the result in the destination parameter. The input vector must have size at most equal to the degree of the polynomial modulus. The first half of the elements represent the first row of the matrix, and the second half represent the second row. The numbers in the matrix can be at most equal to the plaintext modulus for it to represent a valid plaintext.</p>
<p>If the destination plaintext overlaps the input values in memory, the behavior of this function is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>The matrix of integers modulo plaintext modulus to batch </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>The plaintext polynomial to overwrite with the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if values is too large </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa94607373c39f0d3f6dccec9b8c31d02" name="aa94607373c39f0d3f6dccec9b8c31d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94607373c39f0d3f6dccec9b8c31d02">&#9670;&#160;</a></span>slot_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SEAL_NODISCARD auto seal::BatchEncoder::slot_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of slots. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>seal/<a class="el" href="batchencoder_8h_source.html">batchencoder.h</a></li>
<li>seal/batchencoder.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
