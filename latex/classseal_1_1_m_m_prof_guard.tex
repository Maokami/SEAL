\doxysection{seal\+::MMProf\+Guard Class Reference}
\hypertarget{classseal_1_1_m_m_prof_guard}{}\label{classseal_1_1_m_m_prof_guard}\index{seal::MMProfGuard@{seal::MMProfGuard}}


{\ttfamily \#include $<$memorymanager.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classseal_1_1_m_m_prof_guard_a54f489c658042be2dd361f2fa8d5be91}{MMProf\+Guard}} (std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classseal_1_1_m_m_prof}{MMProf}} $>$ \&\&mm\+\_\+prof, bool start\+\_\+locked=true) noexcept
\item 
\mbox{\hyperlink{classseal_1_1_m_m_prof_guard_a09ffc9fe20308a85d54c0d7842daf6d6}{MMProf\+Guard}} (\mbox{\hyperlink{classseal_1_1_m_m_prof}{MMProf}} \texorpdfstring{$\ast$}{*}\&\&mm\+\_\+prof, bool start\+\_\+locked=true) noexcept
\item 
bool \mbox{\hyperlink{classseal_1_1_m_m_prof_guard_a6d47820ee3b0633c6b6a8987a8b264b7}{try\+\_\+lock}} ()
\item 
void \mbox{\hyperlink{classseal_1_1_m_m_prof_guard_a5211c21bfd6e81ff2f505577882a5bce}{lock}} ()
\item 
bool \mbox{\hyperlink{classseal_1_1_m_m_prof_guard_a1bd7224043ab6dcbd24185fb2d3e8f12}{try\+\_\+lock}} (std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classseal_1_1_m_m_prof}{MMProf}} $>$ \&\&mm\+\_\+prof)
\item 
void \mbox{\hyperlink{classseal_1_1_m_m_prof_guard_a9ca5f1d74ae2a567d35fa391a94477e4}{lock}} (std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classseal_1_1_m_m_prof}{MMProf}} $>$ \&\&mm\+\_\+prof)
\item 
bool \mbox{\hyperlink{classseal_1_1_m_m_prof_guard_a008f383751a5778cd877ab5d9db8d890}{try\+\_\+lock}} (\mbox{\hyperlink{classseal_1_1_m_m_prof}{MMProf}} \texorpdfstring{$\ast$}{*}\&\&mm\+\_\+prof)
\item 
void \mbox{\hyperlink{classseal_1_1_m_m_prof_guard_a09558e9ee30814f51099df0668d764de}{lock}} (\mbox{\hyperlink{classseal_1_1_m_m_prof}{MMProf}} \texorpdfstring{$\ast$}{*}\&\&mm\+\_\+prof)
\item 
void \mbox{\hyperlink{classseal_1_1_m_m_prof_guard_a940a3f4bf56565129313e7f2921f7266}{unlock}} ()
\item 
\mbox{\hyperlink{classseal_1_1_m_m_prof_guard_a73cbf7f0be45a91e6fd825c49dd56547}{\texorpdfstring{$\sim$}{\string~}\+MMProf\+Guard}} ()
\item 
bool \mbox{\hyperlink{classseal_1_1_m_m_prof_guard_acb7164b4c0d7d469ea17eaa5124024f9}{owns\+\_\+lock}} () noexcept
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Class for a scoped switch of memory manager profile. This class acts as a scoped \"{}guard\"{} for changing the memory manager profile so that the programmer does not have to explicitly switch back afterwards and that other threads cannot change the \doxylink{classseal_1_1_m_m_prof}{MMProf}. It can also help with exception safety by guaranteeing that the profile is switched back to the original if a function throws an exception after changing the profile for local use. 

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classseal_1_1_m_m_prof_guard_a54f489c658042be2dd361f2fa8d5be91}\label{classseal_1_1_m_m_prof_guard_a54f489c658042be2dd361f2fa8d5be91} 
\index{seal::MMProfGuard@{seal::MMProfGuard}!MMProfGuard@{MMProfGuard}}
\index{MMProfGuard@{MMProfGuard}!seal::MMProfGuard@{seal::MMProfGuard}}
\doxysubsubsection{\texorpdfstring{MMProfGuard()}{MMProfGuard()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily seal\+::\+MMProf\+Guard\+::\+MMProf\+Guard (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classseal_1_1_m_m_prof}{MMProf}} $>$ \&\&}]{mm\+\_\+prof,  }\item[{bool}]{start\+\_\+locked = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Creates a new \doxylink{classseal_1_1_m_m_prof_guard}{MMProf\+Guard}. If start\+\_\+locked is true, this function will attempt to lock the \doxylink{classseal_1_1_memory_manager}{Memory\+Manager} for profile switch to mm\+\_\+prof, perform the switch, and keep the lock until unlocked or destroyed. If start\+\_\+lock is false, mm\+\_\+prof will be stored but the switch will not be performed and a lock will not be obtained until \doxylink{classseal_1_1_m_m_prof_guard_a5211c21bfd6e81ff2f505577882a5bce}{lock()} is explicitly called.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em mm\+\_\+prof} & Pointer to a new memory manager profile \\
\hline
\mbox{\texttt{ in}}  & {\em start\+\_\+locked} & Bool indicating whether the lock should be immediately obtained (true by default) \\
\hline
\end{DoxyParams}
\Hypertarget{classseal_1_1_m_m_prof_guard_a09ffc9fe20308a85d54c0d7842daf6d6}\label{classseal_1_1_m_m_prof_guard_a09ffc9fe20308a85d54c0d7842daf6d6} 
\index{seal::MMProfGuard@{seal::MMProfGuard}!MMProfGuard@{MMProfGuard}}
\index{MMProfGuard@{MMProfGuard}!seal::MMProfGuard@{seal::MMProfGuard}}
\doxysubsubsection{\texorpdfstring{MMProfGuard()}{MMProfGuard()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily seal\+::\+MMProf\+Guard\+::\+MMProf\+Guard (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseal_1_1_m_m_prof}{MMProf}} \texorpdfstring{$\ast$}{*}\&\&}]{mm\+\_\+prof,  }\item[{bool}]{start\+\_\+locked = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Creates a new \doxylink{classseal_1_1_m_m_prof_guard}{MMProf\+Guard}. If start\+\_\+locked is true, this function will attempt to lock the \doxylink{classseal_1_1_memory_manager}{Memory\+Manager} for profile switch to mm\+\_\+prof, perform the switch, and keep the lock until unlocked or destroyed. If start\+\_\+lock is false, mm\+\_\+prof will be stored but the switch will not be performed and a lock will not be obtained until \doxylink{classseal_1_1_m_m_prof_guard_a5211c21bfd6e81ff2f505577882a5bce}{lock()} is explicitly called.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em mm\+\_\+prof} & Pointer to a new memory manager profile \\
\hline
\mbox{\texttt{ in}}  & {\em start\+\_\+locked} & Bool indicating whether the lock should be immediately obtained (true by default) \\
\hline
\end{DoxyParams}
\Hypertarget{classseal_1_1_m_m_prof_guard_a73cbf7f0be45a91e6fd825c49dd56547}\label{classseal_1_1_m_m_prof_guard_a73cbf7f0be45a91e6fd825c49dd56547} 
\index{seal::MMProfGuard@{seal::MMProfGuard}!````~MMProfGuard@{\texorpdfstring{$\sim$}{\string~}MMProfGuard}}
\index{````~MMProfGuard@{\texorpdfstring{$\sim$}{\string~}MMProfGuard}!seal::MMProfGuard@{seal::MMProfGuard}}
\doxysubsubsection{\texorpdfstring{\texorpdfstring{$\sim$}{\string~}MMProfGuard()}{\string~MMProfGuard()}}
{\footnotesize\ttfamily seal\+::\+MMProf\+Guard\+::\texorpdfstring{$\sim$}{\string~}\+MMProf\+Guard (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Destroys the \doxylink{classseal_1_1_m_m_prof_guard}{MMProf\+Guard}. If the memory manager profile switch lock is owned, releases the lock, and resets the profile to the one used before locking. 

\doxysubsection{Member Function Documentation}
\Hypertarget{classseal_1_1_m_m_prof_guard_a5211c21bfd6e81ff2f505577882a5bce}\label{classseal_1_1_m_m_prof_guard_a5211c21bfd6e81ff2f505577882a5bce} 
\index{seal::MMProfGuard@{seal::MMProfGuard}!lock@{lock}}
\index{lock@{lock}!seal::MMProfGuard@{seal::MMProfGuard}}
\doxysubsubsection{\texorpdfstring{lock()}{lock()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void seal\+::\+MMProf\+Guard\+::lock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Locks the \doxylink{classseal_1_1_memory_manager}{Memory\+Manager} for profile switch, performs the switch to currently stored memory manager profile, stores the previously held profile, and keep the lock until unlocked or destroyed. The calling thread will block until the lock can be obtained.


\begin{DoxyExceptions}{Exceptions}
{\em std\+::runtime\+\_\+error} & if the lock is already owned \\
\hline
\end{DoxyExceptions}
\Hypertarget{classseal_1_1_m_m_prof_guard_a09558e9ee30814f51099df0668d764de}\label{classseal_1_1_m_m_prof_guard_a09558e9ee30814f51099df0668d764de} 
\index{seal::MMProfGuard@{seal::MMProfGuard}!lock@{lock}}
\index{lock@{lock}!seal::MMProfGuard@{seal::MMProfGuard}}
\doxysubsubsection{\texorpdfstring{lock()}{lock()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void seal\+::\+MMProf\+Guard\+::lock (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseal_1_1_m_m_prof}{MMProf}} \texorpdfstring{$\ast$}{*}\&\&}]{mm\+\_\+prof }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Locks the \doxylink{classseal_1_1_memory_manager}{Memory\+Manager} for profile switch, performs the switch to the given memory manager profile, stores the previously held profile, and keep the lock until unlocked or destroyed. The calling thread will block until the lock can be obtained.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em mm\+\_\+prof} & Pointer to a new memory manager profile \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::runtime\+\_\+error} & if the lock is already owned \\
\hline
\end{DoxyExceptions}
\Hypertarget{classseal_1_1_m_m_prof_guard_a9ca5f1d74ae2a567d35fa391a94477e4}\label{classseal_1_1_m_m_prof_guard_a9ca5f1d74ae2a567d35fa391a94477e4} 
\index{seal::MMProfGuard@{seal::MMProfGuard}!lock@{lock}}
\index{lock@{lock}!seal::MMProfGuard@{seal::MMProfGuard}}
\doxysubsubsection{\texorpdfstring{lock()}{lock()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void seal\+::\+MMProf\+Guard\+::lock (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classseal_1_1_m_m_prof}{MMProf}} $>$ \&\&}]{mm\+\_\+prof }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Locks the \doxylink{classseal_1_1_memory_manager}{Memory\+Manager} for profile switch, performs the switch to the given memory manager profile, stores the previously held profile, and keep the lock until unlocked or destroyed. The calling thread will block until the lock can be obtained.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em mm\+\_\+prof} & Pointer to a new memory manager profile \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::runtime\+\_\+error} & if the lock is already owned \\
\hline
\end{DoxyExceptions}
\Hypertarget{classseal_1_1_m_m_prof_guard_acb7164b4c0d7d469ea17eaa5124024f9}\label{classseal_1_1_m_m_prof_guard_acb7164b4c0d7d469ea17eaa5124024f9} 
\index{seal::MMProfGuard@{seal::MMProfGuard}!owns\_lock@{owns\_lock}}
\index{owns\_lock@{owns\_lock}!seal::MMProfGuard@{seal::MMProfGuard}}
\doxysubsubsection{\texorpdfstring{owns\_lock()}{owns\_lock()}}
{\footnotesize\ttfamily bool seal\+::\+MMProf\+Guard\+::owns\+\_\+lock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Returns whether the current \doxylink{classseal_1_1_m_m_prof_guard}{MMProf\+Guard} owns the memory manager profile switch lock. \Hypertarget{classseal_1_1_m_m_prof_guard_a6d47820ee3b0633c6b6a8987a8b264b7}\label{classseal_1_1_m_m_prof_guard_a6d47820ee3b0633c6b6a8987a8b264b7} 
\index{seal::MMProfGuard@{seal::MMProfGuard}!try\_lock@{try\_lock}}
\index{try\_lock@{try\_lock}!seal::MMProfGuard@{seal::MMProfGuard}}
\doxysubsubsection{\texorpdfstring{try\_lock()}{try\_lock()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily bool seal\+::\+MMProf\+Guard\+::try\+\_\+lock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Attempts to lock the \doxylink{classseal_1_1_memory_manager}{Memory\+Manager} for profile switch, perform the switch to currently stored memory manager profile, store the previously held profile, and keep the lock until unlocked or destroyed. If the lock cannot be obtained on the first attempt, the function returns false; otherwise returns true.


\begin{DoxyExceptions}{Exceptions}
{\em std\+::runtime\+\_\+error} & if the lock is already owned \\
\hline
\end{DoxyExceptions}
\Hypertarget{classseal_1_1_m_m_prof_guard_a008f383751a5778cd877ab5d9db8d890}\label{classseal_1_1_m_m_prof_guard_a008f383751a5778cd877ab5d9db8d890} 
\index{seal::MMProfGuard@{seal::MMProfGuard}!try\_lock@{try\_lock}}
\index{try\_lock@{try\_lock}!seal::MMProfGuard@{seal::MMProfGuard}}
\doxysubsubsection{\texorpdfstring{try\_lock()}{try\_lock()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily bool seal\+::\+MMProf\+Guard\+::try\+\_\+lock (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classseal_1_1_m_m_prof}{MMProf}} \texorpdfstring{$\ast$}{*}\&\&}]{mm\+\_\+prof }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Attempts to lock the \doxylink{classseal_1_1_memory_manager}{Memory\+Manager} for profile switch, perform the switch to the given memory manager profile, store the previously held profile, and keep the lock until unlocked or destroyed. If the lock cannot be obtained on the first attempt, the function returns false; otherwise returns true.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em mm\+\_\+prof} & Pointer to a new memory manager profile \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::runtime\+\_\+error} & if the lock is already owned \\
\hline
\end{DoxyExceptions}
\Hypertarget{classseal_1_1_m_m_prof_guard_a1bd7224043ab6dcbd24185fb2d3e8f12}\label{classseal_1_1_m_m_prof_guard_a1bd7224043ab6dcbd24185fb2d3e8f12} 
\index{seal::MMProfGuard@{seal::MMProfGuard}!try\_lock@{try\_lock}}
\index{try\_lock@{try\_lock}!seal::MMProfGuard@{seal::MMProfGuard}}
\doxysubsubsection{\texorpdfstring{try\_lock()}{try\_lock()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily bool seal\+::\+MMProf\+Guard\+::try\+\_\+lock (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classseal_1_1_m_m_prof}{MMProf}} $>$ \&\&}]{mm\+\_\+prof }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Attempts to lock the \doxylink{classseal_1_1_memory_manager}{Memory\+Manager} for profile switch, perform the switch to the given memory manager profile, store the previously held profile, and keep the lock until unlocked or destroyed. If the lock cannot be obtained on the first attempt, the function returns false; otherwise returns true.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em mm\+\_\+prof} & Pointer to a new memory manager profile \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::runtime\+\_\+error} & if the lock is already owned \\
\hline
\end{DoxyExceptions}
\Hypertarget{classseal_1_1_m_m_prof_guard_a940a3f4bf56565129313e7f2921f7266}\label{classseal_1_1_m_m_prof_guard_a940a3f4bf56565129313e7f2921f7266} 
\index{seal::MMProfGuard@{seal::MMProfGuard}!unlock@{unlock}}
\index{unlock@{unlock}!seal::MMProfGuard@{seal::MMProfGuard}}
\doxysubsubsection{\texorpdfstring{unlock()}{unlock()}}
{\footnotesize\ttfamily void seal\+::\+MMProf\+Guard\+::unlock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Releases the memory manager profile switch lock for \doxylink{classseal_1_1_memory_manager}{Memory\+Manager}, stores the current profile, and resets the profile to the one used before locking.


\begin{DoxyExceptions}{Exceptions}
{\em std\+::runtime\+\_\+error} & if the lock is not owned \\
\hline
\end{DoxyExceptions}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
seal/memorymanager.\+h\end{DoxyCompactItemize}
